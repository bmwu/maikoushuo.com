<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>麦口说</title>
  
  <subtitle>初心易得, 始终难守</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://bmwu.github.io/"/>
  <updated>2019-05-24T01:51:04.289Z</updated>
  <id>https://bmwu.github.io/</id>
  
  <author>
    <name>麦口</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JAVA 运行排查工具 greys</title>
    <link href="https://bmwu.github.io/2019/05/23/JAVA-%E8%BF%90%E8%A1%8C%E6%8E%92%E6%9F%A5%E5%B7%A5%E5%85%B7-greys/"/>
    <id>https://bmwu.github.io/2019/05/23/JAVA-运行排查工具-greys/</id>
    <published>2019-05-23T07:36:04.000Z</published>
    <updated>2019-05-24T01:51:04.289Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>我们平时在线上或者开发中会遇到各种性能、功能等问题，在运行过程中需要查看方法入参、返回值，或者方法执行的堆栈时间，或者jar冲突时类加载来自那个jar包等问题。我们在开发过程中，可能会打印log日志、手动去打印入参、返回值等，或者自己实现简单的profile方法，代码侵入性大且效率较低；另外我们可以使用类似btrace工具去跟踪，这需要自己去实现btrace脚本，服务端需要启动agent，也有点小麻烦。后来淘宝聚石用scala写了个houseMD，但只支持到jdk1.6，后续也没有更新了；后面又有淘宝同学借鉴了btrace和houseMD，写了Greys，方便定位常见的java问题，下面简单介绍其使用方法。</p><p>下载地址：<a href="http://ompc.oss.aliyuncs.com/greys/release/greys-1.7.6.4-bin.zip" target="_blank" rel="noopener">http://ompc.oss.aliyuncs.com/greys/release/greys-1.7.6.4-bin.zip</a></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ul><li><p><strong>在线安装（推荐）</strong></p><p>请复制以下内容，并粘贴到命令行中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -sLk http://ompc.oss.aliyuncs.com/greys/install.sh|bash</span><br></pre></td></tr></table></figure><p>命令将会下载启动脚本文件<code>greys.sh</code>到当前目录，你可以放在任何地方或加入到<code>$PATH</code>中</p></li><li><p><strong>本地安装</strong></p><p>在某些情况下，目标服务器无法访问远程阿里云主机，此时你需要自行下载greys的安装文件。</p><ol><li><p>下载最新版本的GREYS</p><blockquote><p><a href="http://ompc.oss.aliyuncs.com/greys/release/greys-stable-bin.zip" target="_blank" rel="noopener">http://ompc.oss.aliyuncs.com/greys/release/greys-stable-bin.zip</a></p></blockquote></li><li><p>解压zip文件后，执行以下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd greys</span><br><span class="line">sh ./install-local.sh</span><br></pre></td></tr></table></figure><p>即完成本地安装。</p></li></ol></li></ul><h3 id="待监控应用启动AGENT"><a href="#待监控应用启动AGENT" class="headerlink" title="待监控应用启动AGENT"></a>待监控应用启动AGENT</h3><p>pid为应用进程号<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> ./ga.sh pid</span><br></pre></td></tr></table></figure></p><h3 id="应用监控控制客户端"><a href="#应用监控控制客户端" class="headerlink" title="应用监控控制客户端"></a>应用监控控制客户端</h3><p>pid 为应用进程号， ip为应用所在机器， 3658为agent默认端口号<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./greys.sh pid@ip:3658</span><br></pre></td></tr></table></figure></p><p>或者远程访问telnet ip 3658<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gs.sh ip</span><br></pre></td></tr></table></figure></p><h3 id="命令清单"><a href="#命令清单" class="headerlink" title="命令清单"></a>命令清单</h3><table><thead><tr><th style="text-align:left">命令</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:left"><a href="https://github.com/oldmanpushcart/greys-anatomy/wiki/greys-pdf#help%E5%91%BD%E4%BB%A4" target="_blank" rel="noopener">help</a></td><td>查看命令的帮助文档，每个命令和参数都有很详细的说明</td></tr><tr><td style="text-align:left"><a href="https://github.com/oldmanpushcart/greys-anatomy/wiki/greys-pdf#sc%E5%91%BD%E4%BB%A4" target="_blank" rel="noopener">sc</a></td><td>查看JVM已加载的类信息</td></tr><tr><td style="text-align:left"><a href="https://github.com/oldmanpushcart/greys-anatomy/wiki/greys-pdf#sm%E5%91%BD%E4%BB%A4" target="_blank" rel="noopener">sm</a></td><td>查看已加载的方法信息</td></tr><tr><td style="text-align:left"><a href="https://github.com/oldmanpushcart/greys-anatomy/wiki/greys-pdf#monitor%E5%91%BD%E4%BB%A4" target="_blank" rel="noopener">monitor</a></td><td>方法执行监控</td></tr><tr><td style="text-align:left"><a href="https://github.com/oldmanpushcart/greys-anatomy/wiki/greys-pdf#trace%E5%91%BD%E4%BB%A4" target="_blank" rel="noopener">trace</a></td><td>渲染方法内部调用路径，并输出方法路径上的每个节点上耗时</td></tr><tr><td style="text-align:left"><a href="https://github.com/oldmanpushcart/greys-anatomy/wiki/greys-pdf#ptrace%E5%91%BD%E4%BB%A4" target="_blank" rel="noopener">ptrace</a></td><td>强化版的<code>trace</code>命令。通过指定渲染路径，并可记录下路径中所有方法的入参、返值；与<code>tt</code>命令联动。</td></tr><tr><td style="text-align:left"><a href="https://github.com/oldmanpushcart/greys-anatomy/wiki/greys-pdf#watch%E5%91%BD%E4%BB%A4" target="_blank" rel="noopener">watch</a></td><td>方法执行数据观测</td></tr><tr><td style="text-align:left"><a href="https://github.com/oldmanpushcart/greys-anatomy/wiki/greys-pdf#tt%E5%91%BD%E4%BB%A4" target="_blank" rel="noopener">tt</a></td><td>方法执行数据的时空隧道，记录下指定方法每次调用的入参和返回信息，并能对这些不同的时间下调用进行观测</td></tr><tr><td style="text-align:left"><a href="https://github.com/oldmanpushcart/greys-anatomy/wiki/greys-pdf#stack%E5%91%BD%E4%BB%A4" target="_blank" rel="noopener">stack</a></td><td>输出当前方法被调用的调用路径</td></tr><tr><td style="text-align:left"><a href="https://github.com/oldmanpushcart/greys-anatomy/wiki/greys-pdf#js%E5%91%BD%E4%BB%A4" target="_blank" rel="noopener">js</a></td><td>支持使用JavaScript脚本；支持CommonJS部分规范模块化（BMD规范）</td></tr><tr><td style="text-align:left"><a href="https://github.com/oldmanpushcart/greys-anatomy/wiki/greys-pdf#version%E5%91%BD%E4%BB%A4" target="_blank" rel="noopener">version</a></td><td>输出当前目标Java进程所加载的Greys版本号</td></tr><tr><td style="text-align:left"><a href="https://github.com/oldmanpushcart/greys-anatomy/wiki/greys-pdf#quit%E5%91%BD%E4%BB%A4" target="_blank" rel="noopener">quit</a></td><td>退出greys客户端</td></tr><tr><td style="text-align:left"><a href="https://github.com/oldmanpushcart/greys-anatomy/wiki/greys-pdf#shutdown%E5%91%BD%E4%BB%A4" target="_blank" rel="noopener">shutdown</a></td><td>关闭greys服务端</td></tr><tr><td style="text-align:left"><a href="https://github.com/oldmanpushcart/greys-anatomy/wiki/greys-pdf#reset%E5%91%BD%E4%BB%A4" target="_blank" rel="noopener">reset</a></td><td>重置增强类，将被greys增强过的类全部还原</td></tr><tr><td style="text-align:left"><a href="https://github.com/oldmanpushcart/greys-anatomy/wiki/greys-pdf#session%E5%91%BD%E4%BB%A4" target="_blank" rel="noopener">session</a></td><td>查看当前会话</td></tr><tr><td style="text-align:left"><a href="https://github.com/oldmanpushcart/greys-anatomy/wiki/greys-pdf#jvm%E5%91%BD%E4%BB%A4" target="_blank" rel="noopener">jvm</a></td><td>查看当前JVM的信息</td></tr></tbody></table><h4 id="访问agent"><a href="#访问agent" class="headerlink" title="访问agent"></a>访问agent</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet 10.57.17.146 3658   或  ./greys.sh 17602</span><br></pre></td></tr></table></figure><h4 id="查看JVM已加载的类信息"><a href="#查看JVM已加载的类信息" class="headerlink" title="查看JVM已加载的类信息"></a>查看JVM已加载的类信息</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc -df cn.fraudmetrix.norns.controller.ListValueController</span><br></pre></td></tr></table></figure><h4 id="查看类方法"><a href="#查看类方法" class="headerlink" title="查看类方法"></a>查看类方法</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sm -d cn.fraudmetrix.norns.controller.ListValueController *</span><br></pre></td></tr></table></figure><h4 id="统计一段周期类方法执行情况（默认120s）"><a href="#统计一段周期类方法执行情况（默认120s）" class="headerlink" title="统计一段周期类方法执行情况（默认120s）"></a>统计一段周期类方法执行情况（默认120s）</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">monitor -c 5 *ListValueController queryCache</span><br></pre></td></tr></table></figure><h4 id="追踪方法执行链"><a href="#追踪方法执行链" class="headerlink" title="追踪方法执行链"></a>追踪方法执行链</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trace cn.fraudmetrix.norns.controller.ListValueController queryCache</span><br></pre></td></tr></table></figure><h4 id="查看方法执行时间"><a href="#查看方法执行时间" class="headerlink" title="查看方法执行时间"></a>查看方法执行时间</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptrace  -t -n 5 cn.fraudmetrix.norns.controller.ListValueController queryCache</span><br></pre></td></tr></table></figure><h4 id="查看入参"><a href="#查看入参" class="headerlink" title="查看入参"></a>查看入参</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch -b cn.fraudmetrix.norns.controller.ListValueController queryCache '"partnerCode="+params[0]'</span><br></pre></td></tr></table></figure><h4 id="查看返回值"><a href="#查看返回值" class="headerlink" title="查看返回值"></a>查看返回值</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch -s cn.fraudmetrix.norns.controller.ListValueController queryCache returnObj -x 4</span><br></pre></td></tr></table></figure><h4 id="统计方法执行时间"><a href="#统计方法执行时间" class="headerlink" title="统计方法执行时间"></a>统计方法执行时间</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tt -t -n 3 cn.fraudmetrix.norns.controller.ListValueController queryCache</span><br></pre></td></tr></table></figure><h4 id="重放请求"><a href="#重放请求" class="headerlink" title="重放请求"></a>重放请求</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tt -i 1055 -p</span><br></pre></td></tr></table></figure><h4 id="查看方法栈"><a href="#查看方法栈" class="headerlink" title="查看方法栈"></a>查看方法栈</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack cn.fraudmetrix.norns.controller.ListValueController queryCache</span><br></pre></td></tr></table></figure><p>参考地址：<br><a href="https://github.com/oldmanpushcart/greys-anatomy/wiki/greys-pdf" target="_blank" rel="noopener">https://github.com/oldmanpushcart/greys-anatomy/wiki/greys-pdf</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;我们平时在线上或者开发中会遇到各种性能、功能等问题，在运行过程中需要查看方法入参、返回值，或者方法执行的堆栈时间，或者jar冲突时类加载来自
      
    
    </summary>
    
    
      <category term="Java" scheme="https://bmwu.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JAVA JAVA_HOME</title>
    <link href="https://bmwu.github.io/2019/05/23/JAVA-JAVA-HOME/"/>
    <id>https://bmwu.github.io/2019/05/23/JAVA-JAVA-HOME/</id>
    <published>2019-05-23T07:13:11.000Z</published>
    <updated>2019-05-23T07:31:29.288Z</updated>
    
    <content type="html"><![CDATA[<h3 id="查看JAVA版本"><a href="#查看JAVA版本" class="headerlink" title="查看JAVA版本"></a>查看JAVA版本</h3><p>打开Mac电脑，查看JAVA版本，打开终端Terminal，通过命令行查看java版本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> java -version</span></span><br><span class="line">java version "1.8.0_60"</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_60-b27)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.60-b23, mixed mode)</span><br></pre></td></tr></table></figure><p>发现已安装Java运行环境。如果你的系统已经安装成功JDK，通过java -version就可以看到相应的jdk版本。如果你的电脑还没有安装JDK的话，可以到Oracle官网下载jdk。</p><h3 id="查看JAVA安装路径"><a href="#查看JAVA安装路径" class="headerlink" title="查看JAVA安装路径"></a>查看JAVA安装路径</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">which</span> java</span></span><br><span class="line">/usr/bin/java</span><br><span class="line"><span class="meta">$</span><span class="bash"> whereis java</span></span><br><span class="line">/usr/bin/java</span><br></pre></td></tr></table></figure><p>通过<code>ls -l  /usr/bin/java</code> 不能找到真实的安装路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Many Java applications need to know the location of a $JAVA_HOME directory. The $JAVA_HOME on Mac OS X should be found using the /usr/libexec/java_home command line tool on Mac OS X 10.5 or later. On older Mac OS X versions where the tool does not exist, use the fixed path &quot;/Library/Java/Home&quot;. The /usr/libexec/java_home tool dynamically finds the top Java version specified in Java Preferences for the current user. This path allows access to the bin subdirectory where command line tools such as java, javac, etc. exist as on other platforms. The tool /usr/libexec/java_home allows you to specify a particular CPU architecture and Java platform version when locating a $JAVA_HOME.</span><br><span class="line">Another advantage of dynamically finding this path, as opposed to hardcoding the fixed endpoint, is that it is updated when a new version of Java is downloaded via Software Update or installed with a newer version of Mac OS X. For this reason, it is important that developers do not install files in the JDKs inside of /System, since the changes will be lost with subsequent updates by newer versions of Java.</span><br><span class="line">To obtain the path to the currently executing $JAVA_HOME, use the java.home System property.</span><br></pre></td></tr></table></figure><p>参照苹果的文件文档说明<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> /usr/libexec/java_home -V</span></span><br><span class="line">Matching Java Virtual Machines (1):</span><br><span class="line">    1.8.0_60, x86_64:"Java SE 8"/Library/Java/JavaVirtualMachines/jdk1.8.0_60.jdk/Contents/Home</span><br><span class="line"></span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk1.8.0_60.jdk/Contents/Home</span><br></pre></td></tr></table></figure></p><h3 id="设置JAVA-HOME环境变量"><a href="#设置JAVA-HOME环境变量" class="headerlink" title="设置JAVA_HOME环境变量"></a>设置JAVA_HOME环境变量</h3><p>cd回到用户目录，再列出当前的所有文件，可以见到当前系统的.开头的所有文件。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vi .bash_profile</span></span><br><span class="line">export JAVA_HOME=$(/usr/libexec/java_home)</span><br><span class="line">export PATH=$JAVA_HOME/bin:$PATH</span><br><span class="line">export CLASS_PATH=$JAVA_HOME/lib</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">source</span> .bash_profile</span></span><br></pre></td></tr></table></figure></p><p>到这个步骤，我们就已经配置好了全局的java的path和classpath环境变量。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$JAVA_HOME</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$PATH</span></span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;查看JAVA版本&quot;&gt;&lt;a href=&quot;#查看JAVA版本&quot; class=&quot;headerlink&quot; title=&quot;查看JAVA版本&quot;&gt;&lt;/a&gt;查看JAVA版本&lt;/h3&gt;&lt;p&gt;打开Mac电脑，查看JAVA版本，打开终端Terminal，通过命令行查看java版本：&lt;/
      
    
    </summary>
    
    
      <category term="Java" scheme="https://bmwu.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Hexo-使用 GitHub Issues 搭建评论系统</title>
    <link href="https://bmwu.github.io/2019/05/22/Hexo-%E4%BD%BF%E7%94%A8GitHubIssues%E6%90%AD%E5%BB%BA%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/"/>
    <id>https://bmwu.github.io/2019/05/22/Hexo-使用GitHubIssues搭建评论系统/</id>
    <published>2019-05-22T07:32:59.000Z</published>
    <updated>2019-05-22T07:45:26.209Z</updated>
    
    <content type="html"><![CDATA[<p>gitment的介绍，直接 <a href="https://imsun.net/posts/gitment-introduction/" target="_blank" rel="noopener">https://imsun.net/posts/gitment-introduction/</a><br>我就简单描述下我遇到的问题</p><h3 id="Gitment配置信息"><a href="#Gitment配置信息" class="headerlink" title="Gitment配置信息"></a>Gitment配置信息</h3><p>我使用的是next主题，_config.yml下面配置, 需要注意的是</p><ol><li>owner是 <a href="https://github.com/bmwu" target="_blank" rel="noopener">https://github.com/bmwu</a> 里面的bmwu</li><li>repo是 <a href="https://github.com/bmwu/bmwu.github.io" target="_blank" rel="noopener">https://github.com/bmwu/bmwu.github.io</a> 里面的 bmwu.github.io</li><li>所有的变量都需要加 ‘’，不要comments加载不出来的</li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">gitment:</span></span><br><span class="line">  <span class="comment"># Switch</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Your Github ID (Github username):</span></span><br><span class="line"><span class="attr">  owner:</span></span><br><span class="line">  <span class="comment"># The repo to store comments:</span></span><br><span class="line"><span class="attr">  repo:</span> </span><br><span class="line">  <span class="comment"># Your client ID:</span></span><br><span class="line"><span class="attr">  client_id:</span> <span class="string">''</span></span><br><span class="line">  <span class="comment"># Your client secret:</span></span><br><span class="line"><span class="attr">  client_secret:</span> <span class="string">''</span></span><br></pre></td></tr></table></figure><h3 id="gitment-swig"><a href="#gitment-swig" class="headerlink" title="gitment.swig"></a>gitment.swig</h3><p>直接上文件，需要注意的是id可以配置为 page.title；id不配置会报”validation error”；id设置为location.href，是强指定了，会出现所有文章都是相同的comments</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;% <span class="keyword">if</span> theme.gitment.enable and theme.gitment.client_id and theme.gitment.client_secret %&#125;</span><br><span class="line">    &lt;div id=<span class="string">"container_gitment"</span>&gt;&lt;/div&gt;</span><br><span class="line">    &lt;link rel=<span class="string">"stylesheet"</span> href=<span class="string">"https://imsun.github.io/gitment/style/default.css"</span>&gt;</span><br><span class="line">    &lt;script src=<span class="string">"https://imsun.github.io/gitment/dist/gitment.browser.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">      <span class="keyword">var</span> gitment = <span class="keyword">new</span> Gitment(&#123;</span><br><span class="line">        id: <span class="string">'&#123;&#123; page.title &#125;&#125;'</span>,</span><br><span class="line">        owner: <span class="string">'&#123;&#123; theme.gitment.github_id &#125;&#125;'</span>,</span><br><span class="line">        repo: <span class="string">'&#123;&#123; theme.gitment.repo &#125;&#125;'</span>,</span><br><span class="line">        oauth: &#123;</span><br><span class="line">          client_id: <span class="string">'&#123;&#123; theme.gitment.client_id &#125;&#125;'</span>,</span><br><span class="line">          client_secret: <span class="string">'&#123;&#123; theme.gitment.client_secret &#125;&#125;'</span>,</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      gitment.render(<span class="string">'container_gitment'</span>);</span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&#123;% endif %&#125;</span></span><br></pre></td></tr></table></figure><h3 id="初始化评论"><a href="#初始化评论" class="headerlink" title="初始化评论"></a>初始化评论</h3><p>现在确实好像需要手动去初始化， 假如你id配置了page.title，当里面存在’或者/时，好像不会出现comments，所以title的命名需要注意下</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;gitment的介绍，直接 &lt;a href=&quot;https://imsun.net/posts/gitment-introduction/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://imsun.net/posts/gitment-intr
      
    
    </summary>
    
    
      <category term="Hexo" scheme="https://bmwu.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>2018总结 - 为爱而生</title>
    <link href="https://bmwu.github.io/2019/05/22/2018%E6%80%BB%E7%BB%93/"/>
    <id>https://bmwu.github.io/2019/05/22/2018总结/</id>
    <published>2019-05-22T01:56:23.000Z</published>
    <updated>2019-05-22T03:44:42.896Z</updated>
    
    <content type="html"><![CDATA[<p>18年早已过去，崭新的19年也已过了1/4，按照国际惯例，一年一度的总结过去计划未来的日子早就应该到来，如今却姗姗来迟。</p><p>18年和以往唯一不同的是，以前只是“怅然若失”的假装自己到了“而立之年”，而19年，真的是步入“而立之年”了，若说自己没有那么一丝的感伤和恐惧，那是自欺欺人，但既然“木已成舟”，也只能欣然接受了，而且这一天终究是要来的。这也可能是人年纪越大，越怕过年的原因之一吧。</p><p>工作的第8个年头，也就是32岁的时候，突然有了一种很强烈的危机感，这种危机感主要来源于年龄的增长，因为你会发现和你一起共事的同事们越来越年轻，当然这不是最要紧的，最要紧的是对工作他们可以投入更多的时间，而你不仅仅是公司的一名员工，所以在处理工作的方式和方法就需要更多的“智慧”，你必须要用更高的“能力”来弥补工作时长上的短板，就像计算机设计中，要用“空间”来换取“时间”的概念一样，所以这些危机感应该是和你的能力成反比的，而这一年为了“应付”这些危机感，加速和加强了我对软件编程的理解，但也因此牺牲了很多健身的时间也是比较遗憾的。</p><p>17年我离开LOCKet，选择来到Terminus；19年我离开Terminus，再次带着期望和问题去往一个新的环境。<br>这一年，很辛苦，数不清的加班，尝不尽的酸甜；这一年，因为有爱情、友情、亲情，为爱而活。</p><h3 id="18年计划"><a href="#18年计划" class="headerlink" title="18年计划"></a>18年计划</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">和家人一起去旅行</span><br><span class="line">和太太一起去旅行</span><br><span class="line">精读10本书并记录观后感 </span><br><span class="line">参加杭州马拉松</span><br><span class="line">给太太一个完美的婚礼</span><br><span class="line">学会一种乐器</span><br><span class="line">打卡五岳之一</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>这一年，我与她迈进了婚姻的殿堂。结婚那天，她当着所有人含泪道：我爱你。很高兴遇见你，一切来的都刚刚好，我会好好爱你，往后余生，请多多指教。</p><p>这一年，带着她去了仙本那。欠你的旅行总需要兑现的。卡帕莱岛那白净的沙滩、清可见底的海水、五彩缤纷的珊瑚礁、自在悠游的鱼群海龟，宛如梦境之地～</p><p>这一年，她学了无数的厨艺，做得了烘培，总能把我吃撑，体重也chengchengcheng的往上窜，也许有一种胖就叫幸福胖吧。</p><p>这一年，我们完成了家庭旅行，深圳/香港/澳门，走过了很多地方，看过了很多风景，带来了新的体验，辛苦了我的她。</p><p>这一年，她实现了诺言，带着我来到了日本关西，暴走3天，走遍京都/神户/奈良，还n进n出药妆店，东西塞满了箱子。</p><p>这一年，第一次去外省参加了婚礼，满满的祝福送给新人。顺道完成了”打卡五岳之一”的衡山，和见识了长沙的美食和人海。相较于衡阳，长沙还是一座比较友好的城市，不过以后估计不会在节假日出游了，各种瘫痪呀。</p><p>这一年，几乎都是八点班车，深夜十点而归，工作/杂事占据了大部分的精力，似乎离学习也渐行渐远。但再忙再累，只要看到她留的便条，都会泛起嘴角，18年，有你真好！</p><p>这一年，认识了”新零售”，接触了”供应链”，探索未知发现视界，满足了我的好奇心。非常多的矛盾和挑战，自己的能力也提升了不少。感谢各位的帮助和提携，和那么多个并肩作战的日夜。</p><p>这一年，我的blog停更了，更多的贡献在了lark，成长很多，不能共享出来与君共勉了。</p><p>这一年，学习了一些新技术，业务架构，技术架构，中间件，分布式，增加了大型分布式、高并发、高负载（大数据量）、高可用性系统设计开发经验。</p><p>这一年，深深的感受了单纯技术的无力感，所以转了型，从技术到产品，做一个会技术的产品，一个会武术的流氓。</p><h3 id="19年计划"><a href="#19年计划" class="headerlink" title="19年计划"></a>19年计划</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">平衡好工作与生活</span><br><span class="line">学会管理情绪</span><br><span class="line">每天运动，坚持10000步 </span><br><span class="line">学会理财，珍惜血汗钱</span><br><span class="line">和家人一起去旅行</span><br><span class="line">和太太一起去旅行</span><br><span class="line">坚持学习，坚持写BLOG</span><br><span class="line">多认识一些新朋友</span><br></pre></td></tr></table></figure><p>初心易得，始终难守，耐撕前行，何必慌张，送给每一个不辜负时间的人，愿我们的每一份努力都不负期望。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;18年早已过去，崭新的19年也已过了1/4，按照国际惯例，一年一度的总结过去计划未来的日子早就应该到来，如今却姗姗来迟。&lt;/p&gt;
&lt;p&gt;18年和以往唯一不同的是，以前只是“怅然若失”的假装自己到了“而立之年”，而19年，真的是步入“而立之年”了，若说自己没有那么一丝的感伤和
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>mac-idea的terminal输入中文乱码问题</title>
    <link href="https://bmwu.github.io/2018/03/06/mac-idea%E7%9A%84terminal%E8%BE%93%E5%85%A5%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/"/>
    <id>https://bmwu.github.io/2018/03/06/mac-idea的terminal输入中文乱码问题/</id>
    <published>2018-03-06T05:40:01.000Z</published>
    <updated>2019-05-21T04:11:57.578Z</updated>
    
    <content type="html"><![CDATA[<p>oh-my-zsh，在~/.zshrc文件中添加上面的配置</p><p>export LANG=”zh_CN.UTF-8”<br>export LC_ALL=”zh_CN.UTF-8”</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;oh-my-zsh，在~/.zshrc文件中添加上面的配置&lt;/p&gt;
&lt;p&gt;export LANG=”zh_CN.UTF-8”&lt;br&gt;export LC_ALL=”zh_CN.UTF-8”&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="terminal" scheme="https://bmwu.github.io/tags/terminal/"/>
    
  </entry>
  
  <entry>
    <title>Mac上MySQL报错：ERROR 2002 (HY000): Can&#39;t connect to local MySQL server through socket &#39;/tmp/mysql.sock&#39;</title>
    <link href="https://bmwu.github.io/2018/03/01/Mac%E4%B8%8AMySQL%E6%8A%A5%E9%94%99%EF%BC%9AERROR-2002-HY000-Can-t-connect-to-local-MySQL-server-through-socket-tmp-mysql-sock/"/>
    <id>https://bmwu.github.io/2018/03/01/Mac上MySQL报错：ERROR-2002-HY000-Can-t-connect-to-local-MySQL-server-through-socket-tmp-mysql-sock/</id>
    <published>2018-03-01T01:45:22.000Z</published>
    <updated>2019-05-21T04:11:57.575Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>执行：<code>$ brew install mysql</code></p></li><li><p>配置文件: <code>/usr/local/etc/my.cnf</code></p></li><li><p>启动：<code>mysql.server start</code></p></li><li><p><code>mysql -uroot -p</code> </p><p>如果不执行3，会出现以下错误：</p><p><code>ERROR 2002 (HY000): Can&#39;t connect to local MySQL server through socket &#39;/tmp/mysql.sock&#39; (2)</code></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;执行：&lt;code&gt;$ brew install mysql&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;配置文件: &lt;code&gt;/usr/local/etc/my.cnf&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;启动：&lt;code&gt;mysql.s
      
    
    </summary>
    
    
      <category term="mysql" scheme="https://bmwu.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>2017总结</title>
    <link href="https://bmwu.github.io/2018/02/26/2017%E6%80%BB%E7%BB%93/"/>
    <id>https://bmwu.github.io/2018/02/26/2017总结/</id>
    <published>2018-02-26T15:29:22.000Z</published>
    <updated>2019-05-21T04:11:57.572Z</updated>
    
    <content type="html"><![CDATA[<p>2017年走过很多城市，重庆，西宁，西藏，西安，舟山，宁波，温州和北京。这一年，从臻至到端点，离开待了一年多的臻至，西湖、拱墅、西湖、余杭，历时7年，终归选择回滨江。</p><p>我带着期待和问题来到了一个新环境，开始新探索，试着找寻下一个自我。</p><p>生命如同远行，沿途美丽亦或不美丽的风景，我们驻足且必须前行。</p><p>”很高兴遇见你“，这是遇见你的357天，这是个美好的开始，我相信。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2017年走过很多城市，重庆，西宁，西藏，西安，舟山，宁波，温州和北京。这一年，从臻至到端点，离开待了一年多的臻至，西湖、拱墅、西湖、余杭，历时7年，终归选择回滨江。&lt;/p&gt;
&lt;p&gt;我带着期待和问题来到了一个新环境，开始新探索，试着找寻下一个自我。&lt;/p&gt;
&lt;p&gt;生命如同远
      
    
    </summary>
    
    
      <category term="总结" scheme="https://bmwu.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>SQLite</title>
    <link href="https://bmwu.github.io/2017/10/31/SQLite/"/>
    <id>https://bmwu.github.io/2017/10/31/SQLite/</id>
    <published>2017-10-31T12:18:28.000Z</published>
    <updated>2019-05-21T04:11:57.577Z</updated>
    
    <content type="html"><![CDATA[<p>SQLite是一种嵌入式数据库，它的数据库就是一个文件。由于SQLite本身是C写的，而且体积很小，所以，经常被集成到各种应用程序中，甚至在iOS和Android的App中都可以集成。</p><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><p>Python就内置了SQLite3，所以，在Python中使用SQLite，不需要安装任何东西，直接使用。</p><p>在使用SQLite前，我们先要搞清楚几个概念：</p><p>表是数据库中存放关系数据的集合，一个数据库里面通常都包含多个表，比如学生的表，班级的表，学校的表，等等。表和表之间通过外键关联。</p><p>要操作关系数据库，首先需要连接到数据库，一个数据库连接称为Connection；</p><p>连接到数据库后，需要打开游标，称之为Cursor，通过Cursor执行SQL语句，然后，获得执行结果。</p><p>Python定义了一套操作数据库的API接口，任何数据库要连接到Python，只需要提供符合Python标准的数据库驱动即可。</p><p>由于SQLite的驱动内置在Python标准库中，所以我们可以直接来操作SQLite数据库。</p><p>我们在Python交互式命令行实践一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入SQLite驱动:</span></span><br><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"><span class="comment"># 连接到SQLite数据库</span></span><br><span class="line"><span class="comment"># 数据库文件是test.db</span></span><br><span class="line"><span class="comment"># 如果文件不存在，会自动在当前目录创建:</span></span><br><span class="line">conn = sqlite3.connect(<span class="string">'test.db'</span>)</span><br><span class="line"><span class="comment"># 创建一个Cursor:</span></span><br><span class="line">cursor = conn.cursor()</span><br><span class="line"><span class="comment"># 执行一条SQL语句，创建user表:</span></span><br><span class="line">cursor.execute(<span class="string">'create table user (id varchar(20) primary key, name varchar(20))'</span>)</span><br><span class="line"><span class="comment"># 继续执行一条SQL语句，插入一条记录:</span></span><br><span class="line">cursor.execute(<span class="string">'insert into user (id, name) values (\'1\', \'Michael\')'</span>)</span><br><span class="line"><span class="comment"># 通过rowcount获得插入的行数:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cursor.rowcount</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="comment"># 关闭Cursor:</span></span><br><span class="line">cursor.close()</span><br><span class="line"><span class="comment"># 提交事务:</span></span><br><span class="line">conn.commit()</span><br><span class="line"><span class="comment"># 关闭Connection:</span></span><br><span class="line">conn.close()</span><br></pre></td></tr></table></figure><p>我们再试试查询记录：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">conn = sqlite3.connect(<span class="string">'test.db'</span>)</span><br><span class="line">cursor = conn.cursor()</span><br><span class="line"><span class="comment"># 执行查询语句:</span></span><br><span class="line">cursor.execute(<span class="string">'select * from user where id=?'</span>, (<span class="string">'1'</span>,))</span><br><span class="line"><span class="comment"># 获得查询结果集:</span></span><br><span class="line">values = cursor.fetchall()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>values</span><br><span class="line">[(<span class="string">u'1'</span>, <span class="string">u'Michael'</span>)]</span><br><span class="line">cursor.close()</span><br><span class="line">conn.close()</span><br></pre></td></tr></table></figure><p>使用Python的DB-API时，只要搞清楚Connection和Cursor对象，打开后一定记得关闭，就可以放心地使用。</p><p>使用Cursor对象执行<code>insert</code>，<code>update</code>，<code>delete</code>语句时，执行结果由<code>rowcount</code>返回影响的行数，就可以拿到执行结果。</p><p>使用Cursor对象执行<code>select</code>语句时，通过<code>featchall()</code>可以拿到结果集。结果集是一个list，每个元素都是一个tuple，对应一行记录。</p><p>如果SQL语句带有参数，那么需要把参数按照位置传递给<code>execute()</code>方法，有几个<code>?</code>占位符就必须对应几个参数，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cursor.execute(<span class="string">'select * from user where name=? and pwd=?'</span>, (<span class="string">'abc'</span>, <span class="string">'123456'</span>))</span><br></pre></td></tr></table></figure><p>接下来的是python工具类:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SQLITETool</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,databaseName)</span>:</span></span><br><span class="line">        self.databaseName = databaseName</span><br><span class="line">        self.create_db()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_db</span><span class="params">(self)</span>:</span></span><br><span class="line">        conn = sqlite3.connect(self.databaseName)</span><br><span class="line">        conn.close();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">execute_table</span><span class="params">(self,sql)</span>:</span></span><br><span class="line">        conn = sqlite3.connect(self.databaseName);</span><br><span class="line">        cursor = conn.cursor();</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            cursor.execute(sql)</span><br><span class="line">        <span class="keyword">except</span> Exception, e:</span><br><span class="line">            print(Exception,<span class="string">":"</span>,e)</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            cursor.close()</span><br><span class="line">            conn.commit()</span><br><span class="line">            conn.close()</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>在Python中操作数据库时，要先导入数据库对应的驱动，然后，通过Connection对象和Cursor对象操作数据。</p><p>要确保打开的Connection对象和Cursor对象都正确地被关闭，否则，资源就会泄露。</p><p>如何才能确保出错的情况下也关闭掉Connection对象和Cursor对象呢？请回忆<code>try:...except:...finally:...</code>的用法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;SQLite是一种嵌入式数据库，它的数据库就是一个文件。由于SQLite本身是C写的，而且体积很小，所以，经常被集成到各种应用程序中，甚至在iOS和Android的App中都可以集成。&lt;/p&gt;
&lt;h2 id=&quot;Python&quot;&gt;&lt;a href=&quot;#Python&quot; class=
      
    
    </summary>
    
    
      <category term="SQLites" scheme="https://bmwu.github.io/tags/SQLites/"/>
    
  </entry>
  
  <entry>
    <title>JAVA 从一个 NullPointerException 探究自动装箱拆箱机制</title>
    <link href="https://bmwu.github.io/2017/10/17/JAVA-%E4%BB%8E%E4%B8%80%E4%B8%AA-NullPointerException-%E6%8E%A2%E7%A9%B6%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E6%8B%86%E7%AE%B1%E6%9C%BA%E5%88%B6/"/>
    <id>https://bmwu.github.io/2017/10/17/JAVA-从一个-NullPointerException-探究自动装箱拆箱机制/</id>
    <published>2017-10-17T07:46:39.000Z</published>
    <updated>2019-05-21T06:53:35.341Z</updated>
    
    <content type="html"><![CDATA[<p>今天遇到了一个 NullPointerException，触发的代码类似下面这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Double <span class="title">getRatio</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Double ratio1 = getRatio();</span><br><span class="line">        Double ratio2 = <span class="number">1.0</span> - ratio1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当obj.getRatio() 返回null时, <code>Double ratio2 = 1.0 - ratio1;</code>实际上相当于调用 <code>Double ratio2 = 1.0 - null;</code></p><h2 id="抛出问题"><a href="#抛出问题" class="headerlink" title="抛出问题"></a>抛出问题</h2><p>运行时 <code>Double ratio2 = 1.0 - ratio1;</code>这一行抛出NullPointerException.</p><h2 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h2><p>ratio1是Double类型(虽然其实是null), 这里会经历一次从类型Double到基本数据类型double的自动拆箱过程.</p><p>用命令javac HelloWorld.java 将以上代码编译出HelloWorld.class文件</p><p>之后再用命令javap -c HelloWorld.class，将其字节码文件进行反汇编,:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Compiled from <span class="string">"HelloWorld.java"</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">bmwu</span>.<span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> com.bmwu.HelloWorld();</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> java.lang.<span class="function">Double <span class="title">getRatio</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aconst_null</span><br><span class="line">       <span class="number">1</span>: areturn</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       0: invokestatic  #2                  // Method getRatio:()Ljava/lang/Double;</span><br><span class="line">       <span class="number">3</span>: astore_1</span><br><span class="line">       <span class="number">4</span>: dconst_1</span><br><span class="line">       <span class="number">5</span>: aload_1</span><br><span class="line">       6: invokevirtual #3                  // Method java/lang/Double.doubleValue:()D</span><br><span class="line">       <span class="number">9</span>: dsub</span><br><span class="line">      10: invokestatic  #4                  // Method java/lang/Double.valueOf:(D)Ljava/lang/Double;</span><br><span class="line">      <span class="number">13</span>: astore_2</span><br><span class="line">      <span class="number">22</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从以上字节码及对应的注释可以看出, <code>Double ratio2 = 1.0 - ratio1;</code>这一行被编译后等同于如下代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Double var2 = Double.valueOf(<span class="number">1.0</span>D - var1.doubleValue());</span><br></pre></td></tr></table></figure><p>这一行看起来就是自动拆箱的过程了, 而ratio1的value为null,  var1,doubleValue() 会抛出NullPointerException.</p><h2 id="自动装箱与拆箱"><a href="#自动装箱与拆箱" class="headerlink" title="自动装箱与拆箱"></a>自动装箱与拆箱</h2><p>自动装箱与拆箱是Java1.5引入的新特性, 是一种语法糖.</p><p>在此之前, 我们要创建一个值为10的Integer对象, 只能写作</p><p><code>Integer value = new Integer(10);</code></p><p>而现在, 我们可以更方便地写为:</p><p><code>Integer value = 10;</code></p><h2 id="定义与实现机制"><a href="#定义与实现机制" class="headerlink" title="定义与实现机制"></a>定义与实现机制</h2><p><strong>自动装箱</strong>，是指从基本数据类型值到其对应的包装类对象的自动转换。比如 <code>Integer value = 10;</code>，是通过调用 Integer.valueOf 方法实现转换的。</p><p><strong>自动拆箱</strong>，是指从包装类对象到其对应的基本数据类型值的自动转换。比如 <code>int primitive = value;</code>，是通过调用 Integer.intValue 方法实现转换的。</p><table><thead><tr><th>基本数据类型</th><th>包装类型</th><th>装箱方法</th><th>拆箱方法</th></tr></thead><tbody><tr><td>boolean</td><td>Boolean</td><td>Boolean.valueOf(boolean)</td><td>Boolean.booleanValue()</td></tr><tr><td>byte</td><td>Byte</td><td>Byte.valueOf(byte)</td><td>Byte.byteValue()</td></tr><tr><td>char</td><td>Character</td><td>Character.valueOf(char)</td><td>Character.charValue()</td></tr><tr><td>short</td><td>Short</td><td>Short.valueOf(short)</td><td>Short.shortValue()</td></tr><tr><td>int</td><td>Integer</td><td>Integer.valueOf(int)</td><td>Integer.intValue()</td></tr><tr><td>long</td><td>Long</td><td>Long.valueOf(long)</td><td>Long.longValue()</td></tr><tr><td>float</td><td>Float</td><td>Float.valueOf(float)</td><td>Float.floatValue()</td></tr><tr><td>double</td><td>Double</td><td>Double.valueOf(double)</td><td>Double.doubleValue()</td></tr></tbody></table><h2 id="发生时机"><a href="#发生时机" class="headerlink" title="发生时机"></a>发生时机</h2><p>自动装箱与拆箱主要发生在以下四种时机：</p><ol><li>赋值时；</li><li>比较时；</li><li>算术运算时；</li><li>方法调用时。</li></ol><h2 id="常见应用场景"><a href="#常见应用场景" class="headerlink" title="常见应用场景"></a>常见应用场景</h2><p><strong>Case 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer value = 10; // 自动装箱（赋值时）</span><br><span class="line"></span><br><span class="line">int primitive = value; // 自动拆箱（方法调用时）</span><br></pre></td></tr></table></figure><p><strong>Case 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Integer value = 1000;</span><br><span class="line">// ...</span><br><span class="line">if (value &lt;= 1000) &#123; // 自动拆箱（比较时）</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Case 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">list.add(10); // 自动装箱（方法调用时）</span><br><span class="line"></span><br><span class="line">int i = list.get(0); // 自动拆箱（赋值时）</span><br></pre></td></tr></table></figure><p><em>注：集合（Collections）里不能直接放入原始类型，集合只接收对象。</em></p><p><strong>Case 4:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal&lt;Integer&gt; local = new ThreadLocal&lt;Integer&gt;();</span><br><span class="line">local.set(10); // 自动装箱（方法调用时）</span><br><span class="line"></span><br><span class="line">int i = local.get(); // 自动拆箱（赋值时）</span><br></pre></td></tr></table></figure><p><em>注：ThreadLocal 不能存储基本数据类型，只接收引用类型。</em></p><p><strong>Case 5:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public void fun1(Integer value) &#123;</span><br><span class="line">    //</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void fun2(int value) &#123;</span><br><span class="line">    //</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void test() &#123;</span><br><span class="line">    fun1(10); // 自动装箱（方法调用时）</span><br><span class="line"></span><br><span class="line">    Integer value = 10;</span><br><span class="line">    fun2(value); // 自动拆箱（方法调用时）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Case 6:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Integer v1 = new Integer(10);</span><br><span class="line">Integer v2 = new Integer(20);</span><br><span class="line">int v3 = 30;</span><br><span class="line"></span><br><span class="line">int sum = v1 + v2; // 自动拆箱（算术运算时）</span><br><span class="line">sum = v1 + 30; // 自动拆箱（算术运算时）</span><br></pre></td></tr></table></figure><h2 id="相关知识点"><a href="#相关知识点" class="headerlink" title="相关知识点"></a>相关知识点</h2><h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><p>除 <code>==</code> 以外，包装类对象与基本数据类型值的比较，包装类对象与包装类对象之间的比较，都是自动拆箱后对基本数据类型值进行比较，所以，<strong>要注意这些类型间进行比较时自动拆箱可能引发的 NullPointerException</strong>。</p><p><code>==</code> 比较特殊，因为可以用于判断左右是否为同一对象，所以两个包装类对象之间 <code>==</code>，会用于判断是否为同一对象，而不会进行自动拆箱操作；包装类对象与基本数据类型值之间 <code>==</code>，会自动拆箱。</p><p>示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Integer v1 = new Integer(10);</span><br><span class="line">Integer v2 = new Integer(20);</span><br><span class="line"></span><br><span class="line">if (v1 &lt; v2) &#123; // 自动拆箱</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (v1 == v2) &#123; // 不拆箱</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (v1 == 10) &#123; // 自动拆箱</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>Java 为整型值包装类 Byte、Character、Short、Integer、Long 设置了缓存，用于存储一定范围内的值，详细如下：</p><table><thead><tr><th>类型</th><th>缓存值范围</th></tr></thead><tbody><tr><td>Byte</td><td>-128 ~ 127</td></tr><tr><td>Character</td><td>0 ~ 127</td></tr><tr><td>Short</td><td>-128 ~ 127</td></tr><tr><td>Integer</td><td>-128 ~ 127（可配置）</td></tr><tr><td>Long</td><td>-128 ~ 127</td></tr></tbody></table><p>在一些情况下，比如自动装箱时，如果值在缓存值范围内，将不创建新对象，直接从缓存里取出对象返回，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Integer v1 = 10;</span><br><span class="line">Integer v2 = 10;</span><br><span class="line">Integer v3 = new Integer(10);</span><br><span class="line">Integer v4 = 128;</span><br><span class="line">Integer v5 = 128;</span><br><span class="line">Integer v6 = Integer.valueOf(10);</span><br><span class="line"></span><br><span class="line">System.out.println(v1 == v2); // true</span><br><span class="line">System.out.println(v1 == v3); // false</span><br><span class="line">System.out.println(v4 == v5); // false</span><br><span class="line">System.out.println(v1 == v6); // true</span><br></pre></td></tr></table></figure><p><strong>缓存实现机制：</strong></p><p>这里使用了设计模式享元模式。</p><p>以 Short 类实现源码为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// ...</span><br><span class="line">public final class Short extends Number implements Comparable&lt;Short&gt; &#123;</span><br><span class="line">    // ...</span><br><span class="line">    private static class ShortCache &#123;</span><br><span class="line">        private ShortCache()&#123;&#125;</span><br><span class="line"></span><br><span class="line">        static final Short cache[] = new Short[-(-128) + 127 + 1];</span><br><span class="line"></span><br><span class="line">        static &#123;</span><br><span class="line">            for(int i = 0; i &lt; cache.length; i++)</span><br><span class="line">                cache[i] = new Short((short)(i - 128));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">    public static Short valueOf(short s) &#123;</span><br><span class="line">        final int offset = 128;</span><br><span class="line">        int sAsInt = s;</span><br><span class="line">        if (sAsInt &gt;= -128 &amp;&amp; sAsInt &lt;= 127) &#123; // must cache</span><br><span class="line">            return ShortCache.cache[sAsInt + offset];</span><br><span class="line">        &#125;</span><br><span class="line">        return new Short(s);</span><br><span class="line">    &#125;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在第一次调用到 <code>Short.valueOf(short)</code> 方法时，将创建 -128 ~ 127 对应的 256 个对象缓存到堆内存里。</p><p>这种设计，在频繁用到这个范围内的值的时候效率较高，可以避免重复创建和回收对象，否则有可能闲置较多对象在内存中。</p><h2 id="使用不当的情况"><a href="#使用不当的情况" class="headerlink" title="使用不当的情况"></a>使用不当的情况</h2><p>自动装箱和拆箱这种语法糖为我们写代码带来了简洁和便利，但如果使用不当，也有可能带来负面影响。</p><ol><li><p>性能的损耗</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Integer sum = 0;</span><br><span class="line">for (int i = 1000; i &lt; 5000; i++) &#123;</span><br><span class="line">    // 1. 先对 sum 进行自动拆箱</span><br><span class="line">    // 2. 加法</span><br><span class="line">    // 3. 自动装箱赋值给 sum，无法命中缓存，会 new Integer(int)</span><br><span class="line">    sum = sum + i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在循环过程中会分别调用 4000 次 Integer.intValue() 和 Integer.valueOf(int)，并 new 4000 个 Integer 对象，而这些操作将 sum 的类型改为 int 即可避免，节约运行时间和空间，提升性能。</p></li><li><p>java.lang.NullPointerException</p><p>尝试对一个值为 null 的包装类对象进行自动拆箱，就有可能造成 NullPointerException。</p><p>比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Integer v1 = null;</span><br><span class="line">int v2 = v1; // NullPointerException</span><br><span class="line"></span><br><span class="line">if (v1 &gt; 10) &#123; // NullPointerException</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int v3 = v1 + 10; // NullPointerException</span><br></pre></td></tr></table></figure><p>还有一种更隐蔽的情形</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        long value = true ? null : 1; // NullPointerException</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这实际上还是对一个值为 null 的 Long 类型进行自动拆箱，反汇编代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Compiled from &quot;Test.java&quot;</span><br><span class="line">public class Test &#123;</span><br><span class="line">  public Test();</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       4: return</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    Code:</span><br><span class="line">       0: aconst_null</span><br><span class="line">       1: checkcast     #2                  // class java/lang/Long</span><br><span class="line">       4: invokevirtual #3                  // Method java/lang/Long.longValue:()J</span><br><span class="line">       7: lstore_1</span><br><span class="line">       8: return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天遇到了一个 NullPointerException，触发的代码类似下面这样：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/spa
      
    
    </summary>
    
    
      <category term="Java" scheme="https://bmwu.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Exception in thread main java.lang.IllegalArgumentException: bound must be greater than origin</title>
    <link href="https://bmwu.github.io/2017/10/13/Exception-in-thread-main-java-lang-IllegalArgumentException-bound-must-be-greater-than-origin/"/>
    <id>https://bmwu.github.io/2017/10/13/Exception-in-thread-main-java-lang-IllegalArgumentException-bound-must-be-greater-than-origin/</id>
    <published>2017-10-13T12:17:59.000Z</published>
    <updated>2019-05-21T04:11:57.573Z</updated>
    
    <content type="html"><![CDATA[<p>先认识下IllegalArgumentException, 它有3个messages, 我们遇到的正式BadRange.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> String BadBound = <span class="string">"bound must be positive"</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> String BadRange = <span class="string">"bound must be greater than origin"</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> String BadSize  = <span class="string">"size must be non-negative"</span>;</span><br></pre></td></tr></table></figure><p>以nextLong为例, 正是因为origin&gt;=bound, 才触发了此Exception</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a pseudorandom &#123;<span class="doctag">@code</span> long&#125; value between the specified</span></span><br><span class="line"><span class="comment"> * origin (inclusive) and the specified bound (exclusive).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> origin the least value returned</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bound the upper bound (exclusive)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a pseudorandom &#123;<span class="doctag">@code</span> long&#125; value between the origin</span></span><br><span class="line"><span class="comment"> *         (inclusive) and the bound (exclusive)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if &#123;<span class="doctag">@code</span> origin&#125; is greater than</span></span><br><span class="line"><span class="comment"> *         or equal to &#123;<span class="doctag">@code</span> bound&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">nextLong</span><span class="params">(<span class="keyword">long</span> origin, <span class="keyword">long</span> bound)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (origin &gt;= bound)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(BadRange);</span><br><span class="line">    <span class="keyword">return</span> internalNextLong(origin, bound);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;先认识下IllegalArgumentException, 它有3个messages, 我们遇到的正式BadRange.&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span 
      
    
    </summary>
    
    
      <category term="Java" scheme="https://bmwu.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>DOMException: Failed to execute &#39;send&#39; on &#39;XMLHttpRequest&#39;</title>
    <link href="https://bmwu.github.io/2017/09/29/DOMException-Failed-to-execute-send-on-XMLHttpRequest/"/>
    <id>https://bmwu.github.io/2017/09/29/DOMException-Failed-to-execute-send-on-XMLHttpRequest/</id>
    <published>2017-09-29T03:25:58.000Z</published>
    <updated>2019-05-21T04:11:57.573Z</updated>
    
    <content type="html"><![CDATA[<p>The problem is the synchronous option specified by:</p><p><code>async: false</code>,<br>This seems not to work in Chrome probably because of the specification of the jQuery’s ajax method, which says:</p><p><strong>Cross-domain requests</strong> and <strong>dataType: “jsonp” requests</strong> do not support synchronous operation.<br>The strange of the situation is that Firefox and Internet Explorer seem to ignore that specification and they both perform the http request and return the XML result.</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    $.ajax(... async: <span class="keyword">false</span> ...); <span class="comment">// Hey browser! first complete this request, </span></span><br><span class="line">                                  <span class="comment">// then go for other codes</span></span><br><span class="line"></span><br><span class="line">    $.ajax(...); <span class="comment">// Executed after the completion of the previous async:false request.</span></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>When async setting is set to false, a Synchronous call is made instead of an Asynchronous call.</p><p>When the async setting of the jQuery AJAX function is set to true then a jQuery Asynchronous call is made. AJAX itself means Asynchronous JavaScript and XML and hence if you make it Synchronous by setting async setting to false, it will no longer be an AJAX call.</p><p>You should mostly always use an asynchronous Ajax Request, in fact I know only about one place where a synchronous Ajax Request should be used which is if you’re in an Ajax Request embedding a new JavaScript file on the client and then referencing types and/or objects from that JavaScript file in the return from the original Ajax Request. Then the fetching of this new JS file should (or can sanely) be included through using a synchronous Ajax Request…</p><p>Other then that you should <em>always</em> use asynchronous Ajax Requests. The most important reason is that a synchronous Ajax Request makes the UI (browser) unresponsive…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;The problem is the synchronous option specified by:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;async: false&lt;/code&gt;,&lt;br&gt;This seems not to work in Chrome probably becaus
      
    
    </summary>
    
    
      <category term="Http" scheme="https://bmwu.github.io/tags/Http/"/>
    
  </entry>
  
  <entry>
    <title>ehcache</title>
    <link href="https://bmwu.github.io/2017/09/27/ehcache/"/>
    <id>https://bmwu.github.io/2017/09/27/ehcache/</id>
    <published>2017-09-27T02:00:31.000Z</published>
    <updated>2019-05-21T04:11:57.578Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Ehcache"><a href="#Ehcache" class="headerlink" title="Ehcache"></a>Ehcache</h2><p>Ehcache is an open source, standards-based cache used to boost performance, offload the database and simplify scalability. Ehcache is robust, proven and full-featured and this has made it the most widely-used Java-based cache.</p><p><a href="https://mvnrepository.com/artifact/net.sf.ehcache" target="_blank" rel="noopener">net.sf.ehcache</a></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/net.sf.ehcache/ehcache --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.sf.ehcache<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ehcache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.10.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Note: This artifact was moved to:</p><table><thead><tr><th>New Group</th><th><a href="https://mvnrepository.com/artifact/org.ehcache" target="_blank" rel="noopener">org.ehcache</a></th></tr></thead><tbody><tr><td>New Artifact</td><td><a href="https://mvnrepository.com/artifact/org.ehcache/ehcache" target="_blank" rel="noopener">ehcache</a></td></tr></tbody></table><p><a href="https://mvnrepository.com/artifact/org.ehcache" target="_blank" rel="noopener">org.ehcache</a> </p><p><code>End-user ehcache3 jar artifact</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.ehcache/ehcache --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.ehcache<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ehcache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Ehcache&quot;&gt;&lt;a href=&quot;#Ehcache&quot; class=&quot;headerlink&quot; title=&quot;Ehcache&quot;&gt;&lt;/a&gt;Ehcache&lt;/h2&gt;&lt;p&gt;Ehcache is an open source, standards-based cache u
      
    
    </summary>
    
    
      <category term="缓存框架" scheme="https://bmwu.github.io/tags/%E7%BC%93%E5%AD%98%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>开发数据库命名规范</title>
    <link href="https://bmwu.github.io/2017/09/24/%E5%BC%80%E5%8F%91%E6%95%B0%E6%8D%AE%E5%BA%93%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/"/>
    <id>https://bmwu.github.io/2017/09/24/开发数据库命名规范/</id>
    <published>2017-09-24T03:52:22.000Z</published>
    <updated>2019-05-21T04:11:57.580Z</updated>
    
    <content type="html"><![CDATA[<p>数据库设计过程中表、字段等的命名规范也算是设计规范的一部分，设计规范更多的是为了确保数据库设计的合理性、为了项目最终的协调稳定性，而命名规范则更多的是为了确保设计的正式和统一. 公正的讲，数据库中表字段等等以什么样的方式命名、取具体什么名字，并不会直接影响到项目的稳定性.</p><p>制定规范的直接目的是约束设计行为，最终目的是确保设计的合理统一。规范虽然是有丰富项目经验的人制定的，但维护的却不是某个人的意志，而是项目的意志，因为遵守此规范对项目是好的有利的，此规范才有意义。所以规范是为了项目利益最大化而在团队人员中形成的一种约定（貌似约定的英文单词Convention本身就有规范的意思），所有参与设计的人员都要遵守此约定，所有参与开发的人员都会依此约定解读设计。我们约定，所有的主键统一命名为id，结果有设计人员违反约定将一个非主键字段命名为id，约定被打破，共识也就被打破，设计人员之间、开发人员与设计人员之间的沟通就出现了隔阂。</p><p>设计规范更多的是为了合理，命名规范更多的是为了统一，团队协作中，统一在某种程度上比局部设计开发的好坏更重要。违反了约定，局部设计开发的再好，反而可能影响到项目整体的稳定协调。</p><h2 id="约定优先于配置-Convention-Over-Configuration"><a href="#约定优先于配置-Convention-Over-Configuration" class="headerlink" title="约定优先于配置(Convention Over Configuration)"></a>约定优先于配置(Convention Over Configuration)</h2><p>在“设计规范”中提到过一些命名规范，也详细讲述了表、字段的类型、注释等属性的设置，为什么要求主键统一命名为id、统一为char(32)类型，为什么要求浮点型数值统一为decimal类型？我们希望团队中所有人看到设计成果，一眼就可以明白这个字段是做什么的、代表的含义是什么，可以但不止于见名知意。再者，当前的开发模式，前后端代码及数据库文档、程序文档、接口文档等等大都是由工具生成，而其最底层的依据就是数据库，表、字段的命名注释同时会影响到工具生成的文档、代码中的类属性方法甚至是前台页面的命名注释，数据库设计命名的规范关系到整个项目的规范。</p><p>命名规范会分四个大模块来介绍：基本规范、名大小写、具体规范、特别说明，各大模块下面有的会有子模块特别说明。</p><h2 id="基本规范"><a href="#基本规范" class="headerlink" title="基本规范"></a><strong>基本规范</strong></h2><blockquote><p>A.可用字符</p></blockquote><p>数据库、表、字段等所有名称的可用字符范围为：A-Z，a-z， 0-9 和_下划线，除此外不允许使用其它字符作为名称。数据库及表名均不允许出现数字，字段名除非特殊情况不允许出现数字。</p><p>在前面介绍关系范式时曾提到过一个破坏范式的例子：平时的多图片上传功能，可能只设计一个字段存储图片名称，这样字段值中就会包含多个图片的名称，里面用|或其它符号分隔。像这种情况，其实也可以设计成三五个字段image_name1、image_name2、image_name3……分别存储，然后限制可上传图片个数，这就是字段名中可出现数字的特殊情况——虽然也不建议这样设计或取名。</p><blockquote><p>B.命名方式</p></blockquote><p>数据库、表、字段等所有名称使用英文单词或英文短语或相应缩写，禁止使用汉语拼音，且均使用单数名，例如：对存储客人信息的表命名为customer而不是customers。名称应该清晰明了，能够准确表达事物的含义，遵循见名知意的原则。</p><p>Oracle表、字段等名称统一使用大写，单词间用<em>下划线分隔；SQLServer数据库、表等名称采用Pascal命名法，字段名称采用Camel命名法，大小写字母混排；MySQL数据库、表、字段等名称统一使用小写，单词间用</em>下划线分隔。至于为何这样规定，下一个模块会有详细介绍。</p><p>Oracle相对特殊，通常的操作顺序是，先创建数据库实例，然后创建表空间，然后创建用户并设定此用户的默认表空间，最后在此用户下建表。多数情况下我们都是只建一个实例，然后在此实例下建不同的表空间、不同的用户，根据不同的用户来区分不同的库。关于实例、表空间及用户的命名方式并无限制，可以采用大小写混排，也可以只用大写或小写，但对于表和字段，我们要求统一为大写。</p><p>我们要求统一为大写或小写的名称，两个单词间用_下划线分隔，SQLServer使用Pascal或Camel方式命名。这些不仅仅是为了数据库设计的可读性，也是为了最终生成代码的可读性。这里简单介绍下编程中常用的三种类、变量、函数等的命名方式：</p><ul><li><p><strong>匈牙利命名法</strong>。由微软的一位匈牙利程序员Charles Simonyi 提出，相对复杂，首字母小写，基本原则是：变量名＝属性＋类型＋对象描述，其中每一对象的名称都要求有明确含义，可以取对象名字全称或名字的一部分。匈牙利命名法主要在C或C++这种面向过程的程序语言中使用，如果用在Java、C#这种面向过程的语言中就很别扭。</p><p>不过自己在写Web前端页面或脚本时，借用了这种命名方式，form表单中涉及的常用HTML标签不外乎如下几种：label、text、button、submit、password、textarea、radio、checkbox、select等，那我在给表单元素命名或者说是给id或name赋值时，就会将元素类型做前缀，例如用户名输入框为textName、性别单选按钮名为radioGender。这样做的好处是我在编写脚本时，根据id或name名称一眼就可以看出这个表单元素是什么类型。在修改页面中初始化表单数据时我可以直接遍历表单元素、根据元素名称判断出元素的类型进而采用适当的赋值动作，而不用逐个选择元素去赋值。</p><p>在<a href="https://link.zhihu.com/?target=http%3A//ASP.NET" target="_blank" rel="noopener">http://ASP.NET**</a>编程中，如果使用微软的服务器控件，在命名时我会用控件类型做名称后缀，例如Name_TextBox、Gender_RadioButtonList等。之所以不再将类型做前缀，一来是VisualStudio本身默认的服务器控件命名方式即时如此，控件类型做后缀；二来是因为服务器控件的类型名称太长，而自己又不愿用缩写，因为没必要，VisualStudio的提示功能强大，后缀的长度不会影响到编程速度。</p></li></ul><ul><li><p><strong>Camel命名法</strong>。即骆驼式命名法，首字母小写，采用该命名法的名称看起来就像骆驼的驼峰一样高低起伏。Camel命名法有两种形式：</p><p>第一种是混合使用大小写字母，例如englishName、fartherCode。在Java中，属性名和方法名一般都采用这种命名方式，在C#中只有属性名采用这种命名方式，我们在前面也规定，SQLServer中字段的命名也采用这种方式。</p><p>第二种是单词之间加下划线，例如english_name、farther_code。我们在前面规定，Oracel和MySQL表、字段的命名都采用这种方式，不过我们要求Oracle全部使用大写字母，MySQL全部使用小写字母。再者，无论是在Java还是C#，甚至是在JavaScript中，所有的常量，都使用这种命名方式，但和Oracle表字段的命名方式一样要全部使用大写字母，比如前面的设计规范中介绍数据字典表时，字典类型、字典项的编码和文本信息需要即时获取，以往的习惯在程序中建立一个常量类，所有用到的字典数据在里面用常量标明，这时常量的命名方式即是如此。</p></li></ul><ul><li><strong>Pascal命名法</strong>。即帕斯卡命名法，与Camel命名法类似，不过是首字母大写。在C#中，类名和方法名一般采用这种命名方式，在Java中类名一般采用这种方式。在前面也规定，SQLServer中数据库、表的命名也采用这种方式。</li></ul><p>除数据库的设计外，不同编程语言、前端HTML标签、JavaScript脚本、样式等等部分都会涉及命名的问题，如果细细整理，项目开发中每个子模块的命名规范都够再出一份长篇文档的。这里只简单介绍下三种常用的命名方式，其它部分的命名方式只是一提，重点还是在数据库的命名规范上。前面说过多次，程序、文档甚至前端页面有大部分通过工具自动生成，只有数据库严格按要求来命名，才能根据不同的编程语言编写不同的代码模板，统一控制生成部分各处的命名方式。比如，我们要求在MySQL数据库中，表名都使用小写，单词间用下划线分隔，交易记录表名称为trade_log，那可以设定生成规则，对应生成的实体类名就是TradeLog，对应生成的Dal层就是TradeLogDal，对应的Service名就是TradeLogService，等等。可如果设计没有规范、不统一，那文档生成规则、代码生成规则、程序编写规则等等也就无法统一制定了。</p><blockquote><p>C.长度限制</p></blockquote><p>关于各种数据库管理系统（DBMS，Database Management System）本身对表、字段等名称的长度限制如下：</p><p><img src="https://pic4.zhimg.com/v2-cf4ad6d3c6ca2534d2e1b7b8b7193edf_b.png" alt="image"></p><p>以上是从网络整理而来，Oracle、SQLServer及MySQL的限制长度亲自测试过。但也有说因为数据库和表的名字可能对应于目录和文件名，故而服务器运行的操作系统可能强加额外的限制。不过除了Oracle的限制长度过短外，其它的一般不会被超出。我们希望名称尽可能详细准确的表达事物含义，但如果过于冗长，就会给操作及后面的程序编写带来诸多不便。</p><blockquote><p>D.单词缩写</p></blockquote><p>自己以往设计数据库时，经常头疼于表、字段的命名，一来找不到好的单词去表述，二来有时可能涉及多个单词，导致名称过长。字段名过长带来的不便有限，最终影响的不过是程序实体类中的一个属性，可如果表名也过长，就比较麻烦了，生成的程序各层间针对此表的类名、变量名都可能受到影响，给后期的编写带来很大不便。使用单词缩写又拿不准，找不到合适的缩写方式。这里建议当表名超过15个字符、字段名超过20个字符时就应该尝试用单词缩写重新命名，如果名称长度在此之内，原则上讲则尽可能不用缩写以使表述具体清晰，表、字段最终的名称长度要严格控制在30个字符以内。关于单词缩写规则如下：</p><p>a． 如果可以在字典里找到一个词的缩写，就用这个做为缩写，比如：Monday=Mon、December=Dec ，可在<a href="http://shortof.com/search/luceneapi_node" target="_blank" rel="noopener">此网站</a>下查找到一些英文单词的缩写</p><p>b． 可以删除单词元音(词首字母除外)和每个单词的重复字母来缩写一个单词。比如：Current = Crnt、Address = Adr、Error = Err、Average = Avg；</p><p>c． 对于主从表，如果主表名称没有缩写而从表的名称需要缩写，则从表名称从第二个单词开始缩写，第一个名词尽可能和主表保持一致。比如企业基本信息表名称为enterprise，则企业诉讼表enterprise_litigation可简写为enterprise_ltg，企业证书表enterprise_certificate可简写为enterprise_crt。最终的数据库表及由数据库表生成的程序在集成开发环境（IDE，Integrated Development Environment ）中是按名称排列的，这样做是为了让相似功能的表、类文件排列在一起，方便开发者操作。</p><p>更详细的单词缩写规则介绍可以参考文档末尾的参考文献。</p><h2 id="名大小写"><a href="#名大小写" class="headerlink" title="名大小写"></a><strong>名大小写</strong></h2><p>理想情况下所有关系型数据库对于表名、字段名、字段内容等大小写的处理会有个大一统的方式，比如要求所有都是大小写敏感的，可实际的情况却是，不同的数据库及同一数据库在不同的操作系统下对大小写的处理都是不同的。以往笔记中记录的第一次遇到数据库处理大小写的问题是，做的一个登录页功能，测试人员发现输入用户名MengXianzhi或mengxianzhi均可以正常登录，但数据库用户表里只有一条用户名为MengXianzhi的记录，当时用的是SQLServer数据库。</p><blockquote><p>A.编码和字符序的介绍</p></blockquote><p>在前面介绍数据库编码时曾经提到，如果使用MySQL Workbench创建新的数据库，会要求选择Collation。Collation的字面意思是字符序，用于指定数据集如何排序、及字符串间的比对规则。可字符本来是不分大小的，这样对字符的&gt;、=、&lt; 操作就需要有个字符序的规则。Collation做的就是这个事情，你可以对表进行字符序的设置，也可以单独对某个字段进行字符序的设置，优先级从高到底可分为四种：服务器层、数据库层、表层、字段层，真正决定性因素是在字段层，如果没有指定则默认从上一层继承过来：字段层继承表层，表继承数据库层，数据库层继承服务器层，服务器层则需要设置，如果不设置默认为latin1_general_ci。</p><p>平时我们说的设置MySQL编码为gbk、gb2312、utf8或lantin等指的是字符编码，也就是Character Set。当表的Character Set 是lantin1时，若字段类型为nvarchar，则字段的字符集自动变为utf8。</p><p>可见数据库、表、字段的Character Set可逐级覆盖，这有点像上面说的四种字符序设置方式间的优先级关系。本规范中建议数据库统一设置编码为utf8，不仅仅是为了应付数据库间导入导出过程中、因编码格式不统一而导致的恼人的乱码问题，也是因为utf8是一种万国码（Unicode）。软件的国际化是大趋势 ， 而Unicode 是国际化最佳的选择。在MySQL中有两个支持 Unicode的Character Set：第一个是UCS2，使用 16 bits 来表示一个 Unicode字符；第二个是utf8，使用 1~3 bytes 来表示一个 Unicode字符。</p><p>那字符编码（Character Set）和字符序（Collation）之间的关系是什么呢？</p><p>每个Character Set 会对应一定数量的 Collation，在MySQL命令窗口中输入Show Collation;命令可以查看到所有字符序及其所属的字符编码列表：</p><p><img src="https://pic4.zhimg.com/v2-65271c7142d84f3c4270804b67394ae3_b.png" alt="image"></p><p>同一个Character Set的不同 Collation 的区别在于排序、字符集对比的准确度以及性能，这里的准确度是指相同两个字符在不同国家语言中的排序规则可能是不同的 ，性能是指排序以及比对速度。例如：utf8_general_ci 在排序的准确度上要逊于 utf8_unicode_ci， 当然，对于英语用户应该没有什么区别，但性能上要略优于 utf8_unicode_ci，例如前者没有对德语中ß = ss的支持。而 utf8_danish_ci 相比 utf8_unicode_ci 增加了对丹麦语的特殊排序支持。</p><p>Collation名字的规则可以归纳为两类：<character set><em>&lt;Language/Other&gt;</em>&lt;CI/CS&gt;以及<character set>_Bin。CI 是Case Insensitive的缩写， CS是Case Sensitive的缩写，即指定数据库对大小写是否敏感。MySQL中Character Set对应的Collation多是CI的，CS这种校验字符已经逐渐被淘汰，gbk、gb2312、utf8等编码的所有Collation没有一个是CS的。Bin表示用二进制存储数据，用编码值进行比较，区分大小写。</character></character></p><p>在上面的截图中也可以看到，gb2312编码默认的Collation是gb2312_chinese_ci、gbk编码默认的Collation是gbk_chinese_ci、utf8编码默认的Collation是utf8_general_ci。按本文档中的规范，建议所有编码统一设置为utf8，如果不单独设置Collation，则按默认的utf8_general_ci，字段值是不区分大小写的。</p><p>那在字符序为CI的情况下，如何在执行SQL查询时区分字段值的大小写呢？假设用户表user中有两个用户：MengXianzhi和mengxianzhi，当我们执行如下查询时会得到两条记录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from user where user_name = &apos;MengXianzhi&apos;;</span><br></pre></td></tr></table></figure><p>如果要区分大小写，有下面两种方式可以精确查询：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from user where binary user_name = &apos;MengXianzhi&apos;;</span><br><span class="line">select * from user where user_name = binary &apos;MengXianzhi&apos;;</span><br></pre></td></tr></table></figure><p>推荐使用第二种查询方式，这样可以保证当前字段的索引依然有效，而第一种会使索引失效。其实个人更倾向于建议统一设置数据库默认的Collation为utf8_bin，也就是对大小写敏感。程序中针对数据库字段内容的比对查询处处都是，英文内容存储也处处都有，如果所有相关查询语句都加binary关键字，太过麻烦，不如在数据库中统一设置，这样也不会出现在本章节开头所描述的问题了。</p><p>如果不想在数据库中统一设置，也可以只针对表、字段单独设置，但非常不建议如此，因为这会导致局部配置和全局配置相悖 。一直坚持规范、约定、配置等尽可能采用大一统的方式，除非不得以。开放局部配置会导致配置的多样性，不利于统一管理维护，不过下面还是会简单介绍下局部配置的方法。</p><blockquote><p>B.编码和字符序的设置</p></blockquote><p>这部分会分别对比MySQL、SQLServer、Oracle三种关系型数据库的字符编码和字符序配置，先从MySQL开始。</p><p>在MySQL中，自己没有找到从服务器层面直接配置Collation的方法，但是数据库、表及具体字段设置Collation的方法都有。再就是在PD中未能找到全局设置Collation的方法，只找到了具体到某一字段设置的地方。截图如下，最后一张是PD中对某一具体字段进行配置的方法：</p><p><img src="https://pic4.zhimg.com/v2-fc3ffc761b80903b2edf63a29e3dbb3b_b.png" alt="image"></p><p><img src="https://pic2.zhimg.com/v2-6e55b0cdc41740f8af78c14d454fc6dd_b.png" alt="image"></p><p><img src="https://pic1.zhimg.com/v2-50e80eb394d31a0e61c4ea191134127c_b.png" alt="image"></p><p><img src="https://pic4.zhimg.com/v2-408cea09eefee5e5f0490d196ebebb27_b.png" alt="image"></p><p>如果要直接更改某一个数据库的Character Set或Collation可以在MySQL Workbench中做如下设置：</p><p><img src="https://pic2.zhimg.com/v2-6d876bdf6ce4825cc17ba3fbb6d54d0d_b.png" alt="image"></p><p><img src="https://pic4.zhimg.com/v2-f4b3f32aac9b6218814ea05c761d0e5b_b.png" alt="image"></p><p>其实Character Set和Collation本就是一体的，所以其实都是在这一个地方设置，两种选项对应的SQL语句就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER SCHEMA `bsctelmed` DEFAULT CHARACTER SET utf8 ;</span><br><span class="line">ALTER SCHEMA `bsctelmed` DEFAULT CHARACTER SET utf8 DEFAULT COLLATE utf8_bin ;</span><br></pre></td></tr></table></figure><p>在SQLServer 2008中，只找到了从数据库层及具体字段层面直接配置Collation的方法，但是从表层面中的配置却没有。和MySQL一样，在PD中未能找到全局设置Collation的方法，只找到了具体到某一字段设置的地方。截图如下，最后一张是PD中对某一具体字段进行配置的方法：</p><p><img src="https://pic2.zhimg.com/v2-cfb3c140419ac6f2f47a64b2275e13b9_b.png" alt="image"></p><p><img src="https://pic4.zhimg.com/v2-b079e10d3aa4b6acf56856dd3cb1bc5b_b.png" alt="image"></p><p><img src="https://pic2.zhimg.com/v2-1d8e21cff0712599547171021015ec49_b.png" alt="image"></p><p>如果想查看SQLServer的版本、字符序等相关信息也可以用如下SQL语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">SERVERPROPERTY(N&apos;Edition&apos;) AS Edition,</span><br><span class="line">SERVERPROPERTY(N&apos;ServerName&apos;) AS ServerName,</span><br><span class="line">SERVERPROPERTY(&apos;ProductVersion &apos;) AS ProductVersion,</span><br><span class="line">SERVERPROPERTY(&apos;ProductLevel&apos;) AS ProductLevel,</span><br><span class="line">SERVERPROPERTY(&apos;ResourceVersion&apos;) AS ResourceVersion,</span><br><span class="line">SERVERPROPERTY(&apos;ResourceLastUpdateDateTime&apos;) AS ResourceLastUpdateDateTime,</span><br><span class="line">SERVERPROPERTY(&apos;Collation&apos;) AS Collation;</span><br></pre></td></tr></table></figure><p>直接在SQL Server Management Studio 图形化界面中更改SQLServer的字符集可能会出现问题：</p><p><img src="https://pic2.zhimg.com/v2-6e2f49813d7f86fb52efa1a8f8b6cb85_b.png" alt="image"></p><p>这时可通过如下更改语句进行更改：</p><p><img src="https://pic1.zhimg.com/v2-2675ff53fb17c0a54f7ea0970beb1148_b.png" alt="image"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER DATABASE HealthManagement COLLATE Chinese_PRC_CI_AS</span><br></pre></td></tr></table></figure><p>在Oracle中貌似没有Collation的概念，又或者是换了另外一个概念来进行类似的设置？在PD中具体到表字段的Oracle选项卡中也没有字符集相关的配置：</p><p><img src="https://pic2.zhimg.com/v2-129fc7359049f2f420f9029f0d3d6071_b.png" alt="image"></p><p>Oracle中默认是严格区分字段内容大小的，如果不想对大小写进行区分可以使用Lower()或Upper()函数来达到目的，也可以使用NLSSORT（）函数，觉得这个函数就和MySQL中的Collation设置所达到的效果相似。如下三个SQL语句所达到的效果是一样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from user where user_name = &apos;MengXianzhi&apos; COLLATE Latin1_General_CI_AI;</span><br><span class="line">select * from user where Upper(user_name) = Upper(&apos;MengXianzhi&apos;);</span><br><span class="line">select * from user where NLSSORT(user_name,&apos;NLS_SORT = Latin_CI&apos;) = NLSSORT(&apos;MengXianzhi&apos;,&apos;NLS_SORT = Latin_CI&apos;);</span><br></pre></td></tr></table></figure><p>但是不清楚上面第三种写法，如果不是精确查询，而是模糊查询，用like关键字，查询语句如何下，尝试下面的写法，好像不起作用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from user where NLSSORT(user_name,&apos;NLS_SORT = Latin_CI&apos;) like NLSSORT(&apos;Meng&apos;,&apos;NLS_SORT = Latin_CI&apos;)+&quot;%&quot;;</span><br></pre></td></tr></table></figure><p>Oracle9i之前，中文是按照二进制编码进行排序的，而在Oracle9i中新增了按照拼音、部首、笔画排序功能，使用方法如下：按汉字拼音排序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM USER ORDER BY NLSSORT(user_name ,&apos;NLS_SORT = SCHINESE_PINYIN_M&apos;)</span><br></pre></td></tr></table></figure><p>按汉字笔划排序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM USER ORDER BY NLSSORT(user_name ,&apos;NLS_SORT = SCHINESE_STROKE_M&apos;)</span><br></pre></td></tr></table></figure><p>按汉字部首排序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM USER ORDER BY NLSSORT(user_name ,&apos;NLS_SORT = SCHINESE_RADICAL_M&apos;)</span><br></pre></td></tr></table></figure><p>注意，我虽然严格测试过MySQL、SQLServer和Oracle三种不同关系型数据库针对CharacterSet和Collation设置的区别，但对于同一数据库的不同版本间的区别却未深究。各种关系型数据库总是在不停升级，某些升级可能会导致新旧版本间差异巨大 ，而本文档中所述细节又甚多，所以具体到实际情况，某些地方出现不同也很正常。</p><blockquote><p>C.由此引出的乱码问题</p></blockquote><p>Character Set和Collation并不仅仅影响到数据库存储内容的大小写敏感问题，还会影响到数据库操作中常见的乱码问题。这里既然提到了，所以简单讲下。</p><p>以往负责的项目较为杂乱，所以对各种常见关系型数据库多有接触，就自己的经验，乱码问题出现最多的是MySQL数据库，尤其是早期版本的MySQL，其次是Oracle，SQLServer当然也有，但相对少。乱码问题可以分为以下几种：</p><p>a． 不同类型的关系型数据库间、数据互相导入导出，导致的中文数据乱码。</p><p>比如将MySQL中的数据导入到SQLServer，将SQLServer中的数据导入到Oracle。这种情况其实相对少见，因为一般数据操作都是在同一类型的数据库间进行。遇到这种情况时，数据间的导入导出一般都有中间过程，比如先从源数据库中将数据导出成CSV文件，然后再将CSV文件导入到目标库。又或者是，借助目标数据库的管理工具，直接连接源数据库进行导入。也有将源数据库中的数据导出成SQL文件，然后对SQL文件进行一定更改后在目标数据库中执行的。</p><p>b． 类型相同、版本不同的关系型数据间的数据导入导出，导致的中文数据乱码。</p><p>c． 类型相同、版本相同的关系型数据间的数据导入导出，导致的中文数据乱码。</p><p>d． 针对Oracle，客户端版本和服务端版本不同所致。客户端的版本比较新、而服务端比较旧，或者是客户端为32位的而服务端是64位等箸。</p><p>e． 主要也是针对Oracle，客户端和客户端所在操作系统不协调、服务端和服务端所在操作系统不协调。比如操作系统为32位，但下载的客户端却是64位的。</p><p>f． 针对程序，官方管理工具操作数据库查询没有问题，但是程序访问数据库查询出的中文却是乱码。</p><p>中文乱码问题在各种数据库的操作中、在种程序语言各种项目的开发中时常出现，针对以上种种我们建议：</p><p>a． 安装及操作数据库时，编码相关的默认设置，除非有把握，否则不要随意更改；</p><p>b． 项目开发环境、测试环境、模拟环境、真实环境、线上环境的操作系统及数据库等尽可能统一版本统一配置，选择和操作系统相匹配的数据库版本；</p><p>c． 针对Oracle数据库，客户端和服务端尽可能统一版本，尽可能选择和操作系统相匹配的客户端及服务端版本；</p><p>d． 在数据库日常操作过程中均使用官方的管理工具，或直接在命令行中操作；SQLServer不用说，MySQL我们建议使用MySQL Workbench，Oracle我们建议使用SQL Developer；</p><p>e． 如果现实情况不方便或不允许达到以上要求，或者虽然按以上要求操作配置数据库后依旧出现乱码问题，那就根据实际情况网络搜索寻求相应解决方案。</p><p>遇到具体问题时刻记得Google是第一位的，仅这一项就可以帮我们解决99%的问题。我们的分析讨论建议更多的是为了全面了解问题本身，但遇到具体问题如何解决，仍旧要靠自己思考、靠Google的智能搜索。下面的截图来自于以往笔记，和某一乱码问题的交锋：</p><p><img src="https://pic1.zhimg.com/v2-6282fee2ad7a88971a5c945f0886524c_b.png" alt="image"></p><blockquote><p>D.表名字段名等大小写</p></blockquote><p>上面讲字符序的大小写敏感，针对的都是数据库表字段值或者说是字段对容，而对于数据库名、表名、字段名、变量名、执行目录名等（在执行SQL查询时）的大小写敏感呢？</p><p>在Linux下MySQL的数据库名、执行目录名、 表名、表的别名、变量名默认是严格区分大小写的，数据库名大小写敏感不可改，执行目录名大小写敏感可参数调配（lower_case_file_system），表名大小写敏感也可参数（lower_case_table_names）调配，但不确定这个参数是否影响表别名及变量名的大小写敏感。列名与列的别名在所有的情况下均是忽略大小写的，也不清楚可否参数调配。</p><p>MySQL在Windows下数据库名、执行目录名、表名、表的别名、变量名、列名、列别名等默认都不区分大小写。</p><p>用root登录服务器修改 /etc/my.cnf配置文件，在[mysqld]节点下，加入一行： lower_case_table_names=1 可以另其不再区分表名大小写。而在 Windows系统下， lower_case_table_names参数缺省设置即为1，即不区分表名大小写。</p><p>在SQLServer中自己测试的结果是，数据库名、用户名、表名、表别名、列名、列别名默认在执行SQL查询时均不区分大小写。SQLServer版本为2008 R2。</p><p><img src="https://pic4.zhimg.com/v2-edfb67dc409b837b8b41cfec8f0fc037_b.png" alt="image"></p><p>在Oracle中自己测试的结果是，实例名、表空间名、用户名、表名、表别名、列名、列别名默认均不区分大小写。Oracle为Linux版本，11.2.0.4。 </p><p><img src="https://pic3.zhimg.com/v2-f5b04cbab90c2e0e4e7bd7084ebec9ee_b.png" alt="image"></p><p>这样整理之后，如下表格：</p><p><img src="https://pic3.zhimg.com/v2-fe90b57872fe5b1c606f2a127187e25a_b.png" alt="image"></p><p>内容中的是否表示默认情况下是否大小写敏感，括号中的（可）表示可参数调配。空白部分表示不确定，或者没有这一项。</p><p>SQLServer和Oracle 、MySQL（Windows系统下）虽然同样默认对表名、字段名等不区分大小写，但不同的是Oracle及MySQL处理的更严谨。通过SQL*Plus、PL/SQL Developer或SQL Devloper在Oracle中建表，默认会自动将表名转换成大写后再写入数据库。 在Windows系统中，默认情况下，建表时MySQL会强制要求所有表名和列名均为小写。SQLServer虽然在执行SQL查询时不区分表名、列名大小写，但在命名及在可视化管理工具中显示时却又区分大小写。也有另外一种可能，目前我测试用的Oracle及MySQL版本比较新，则SQLServer则较旧，最新版的SQLServer或许已经没有这种问题。 </p><p><img src="https://pic3.zhimg.com/v2-d742875c144bb15782fa4efcfff8b4a6_b.png" alt="image"></p><p>前面说通过SQL*Plus、PL/SQL Developer或SQL Devloper在Oracle中建表，默认会自动将表名转换成大写后再写入数据库。但实际上Oracle是可以支持大小写混排的命名方式的，但前提是要在表名外面加双引号。</p><p>仔细查看过，使用PD设计针对Oracle的PDM，如果你的表名全部大写，那PD在生成SQL建表语句时不会在表名外面加双引号，可如果你的表名是大小写混排的，那PD在生成SQL建表语句时会自动在表名外加双引号，保留这种大小写混排的命名方式。其实不光是创建表，在Oracle中创建触发器、序列时也是如此，名字不加引号就不会区分大小写，加上引号就会区分。</p><p>不建议在Oracle中使用大小写混排的命名方式，原因有很多：</p><p>a． 当你使用Oracle SQL Developer工具查看表时，点选“详细资料”选项卡，可能会报错：执行请求的操作时遇到错误，ORA-00904:”STATUS”:invalid identifier。网上搜到ORA-00904错误原因和Oracle建表时表名大小写有关，但不清楚和Oracle版本有没有关系。</p><p>b． 如果表列名都区分大小写，那在建立查询时表名和列名都应该带有双引号，会给后面程序的编写带来麻烦。如果使用Hibernate框架，那其生成的查询是不会带有双引号的，会出现无法找到表或视图的错误。</p><p>c． 使用PL/SQL Developer工具可视化地进行表的删除等操作时，后台采用的是不带双引号的表名，也会出现无法找到表或视图的错误。这时只能采用类似 drop table “tableName” 的语法，在SQL*Plus或PL/SQL Developer手工删除或修改表。</p><p>我们在基本规范中为什么要求MySQL的数据库名、表名、列名等统一为小写，Oracle中的表名、字段名等统一为大写，正是基于以上原因。我们希望藉此规定，将命名大小写规则统一，尽可能的让数据库设计不要在名称大小写这个问题上多出不必要的麻烦。</p><p>这里顺便一提，在PD中可以将PDM中的表名或列名统一转换成大写或小写，菜单Tools——Model Options——Naming——Convertion——Table或Column中进行设置。</p><blockquote><p>E.针对大小写合理建议</p></blockquote><p>个人认为Oracle数据库对表名、字段名、字段内容等大小写敏感的默认处理是最合适的，在执行SQL查询时不区分表名、表别名、列名、列别名的大小写，但严格区分字段内容的大小写。也正因此，我们在基本规范中建议在Oracle数据库的设计过程中表、字段等的名称统一使用大写，单词间用_下划线分隔。</p><p>我们在基本规范中建议，MySQL数据库、表、字段等名称统一使用小写，单词间用_下划线分隔。同时，我们建议在MySQL数据库中将Character Set设置为utf8、将Collation设置为utf8_bin，并在数据库配置文件中设置lower_case_table_names=1，当然，Windows系统中默认就是此种设置，无需再做更改。</p><p>我们建议在SQLServer中将排序规则设置为Chinese_PRC_CS_AS，其默认为Chinese_PRC_CI_AS，因为SQLServer数据库不用考虑部署在不同系统的问题，所以不建议更改除此外的其它编码、字符序相关的默认设置。我们上面也说过SQLServer虽然在执行SQL查询时不区分表名、列名大小写，但在命名及在可视化管理工具中显示时却又区分大小写，为了查看方便所以我们在“基本规范”中要求SQLServer用Pascal的命名方式。</p><p>在“名大小写”这个章节，更多的不是制定规范，而是在讲解前面的“数据编码”、“基本规范”等模块中列出的一些规范制定的原因。在这里详细讲解了MySQL、SQLServer、Oracle三种数据库的编码、字符序相关的配置说明以及表名、字段名、字段内容等大小写敏感的控制处理等。</p><h2 id="具体规范"><a href="#具体规范" class="headerlink" title="具体规范"></a><strong>具体规范</strong></h2><blockquote><p>A.关于数据库的命名</p></blockquote><p>对于数据库的命名不做特别要求，简单明了即可，这里主要注意在一个大环境中相似项目的数据库命名，最好有明显区分。</p><p>这里顺带一提，互联网公司的数据库一般分为五个环境：</p><p>a． 开发环境（Development Environment）。开发可读写，开发人员可以修改表结构，可以随意修改其中的数据；但是需要保证不影响其他开发同事。</p><p>b． 测试环境（Test Environment）。开发可读写，部署的测试系统访问此库，代测试人员使用。</p><p>c． 模拟环境（Simulation Environment ）。 开发可读写，通过web平台，发起上线请求时，会先在这个环境上进行预执行，这个环境也可供部署上线演练或压力测试使用。</p><p>d． 线上从库（Real Environment）。 只读，会实时从线上数据库同步，不允许修改数据，不允许修改表结构。供线上问题查找，数据查询等使用。</p><p>e． 线上环境（Online Environment）。开发人员不允许直接在线上环境进行数据库操作，如果需要操作必须找数据库主负责人，并做相应记录。</p><p>在这些环境中，一定要做到权限划分明确，读写帐号分离，并且有辨识度，能区分具体业务。例如用户名w_wap、r_wap 分别表示对wap数据库进行读、写的帐号。</p><p>做企业内部应用系统，要求不是特别严格的话，没有模拟环境和线上从库。而且通常情况下，线上环境的库在客户那边，开发测试的环境在公司这边，两边还不能互通，有时不得不驻场开发直接连接线上环境。但是对于线上环境的直接操作是非常危险的，且容易导致线上环境和开发测试环境表结构的不同步，这个一定注意。客户那边应该用权限严格限制对生产环境访问的人员，开发人员自己这边要时刻做好数据备份工作，并提前准备好数据出现意外更改或丢失情况的应对措施。同时，在现场开发，针对线上环境的更改要实施同步到公司的开发环境中。线上线下的所有更改，都要经过数据库主设计师的审核同意。</p><p>我们建议，如果可以控制的话，则在不同的数据库环境中统一表空间名、数据库名等，甚至是数据库访问的账号名、权限也可以统一，这样在部署项目时，配置文件则无需再做过多更改，不同数据库环境间有表结构或数据的移植时也可避免出现不必要的问题。在对这些环境的数据库进行备份时，建议在备份文件名中加上前缀和备份时间，以防混淆，比如备份开发环境的数据库可命名为：DevelopmentEnvironment201703271149。这些都是非常细节的地方，有点吹毛求疵，不做强制要求。</p><blockquote><p>B.数据库功能块概述</p></blockquote><p>在前面“设计规范”——“基本原则”——“高级功能”中提到过，现有的开发模式，数据库只用来做数据存储。一直坚持业务相关的部分都由程序处理，不到不得以的情况下不要在数据库中建存储过程、触发器、函数、序列甚至是视图等，尽管如此，这里还是会简单介绍下这些高级功能使用时的命名方式。下面的表格列出了数据库所涵盖常见功能元素的英文名称及缩写：</p><p><img src="https://pic1.zhimg.com/v2-10682d031e96351714599360d8371674_b.png" alt="image"></p><p>有建议，除表和表字段外，其它功能块在命名时均要加英文缩写前缀。但就个人意见，除视图外，其它部分加不加前缀不太重要，视图加前缀是为了在执行查询时和表区分开，而存储过程、函数、约束等，我们一眼即可看出它是什么，更何况在可视化管理工具中，这些功能块本来就是各自独立展示的。所以本规范中不强制要求在这些功能上加前缀，但如果要统一加的话，建议使用上图表格中的英文缩写。</p><blockquote><p>C.关于数据表的命名</p></blockquote><p>关于表的命名，TB这种前缀是毫无意义的，本来就是一个表，为什么还要说明？这也是我上面不建议在其它功能块中加前缀的原因。如果表格数量较少，后期项目扩展升级的可能性不大，也没有必要加其它前缀。但有时规模相对庞大、业务逻辑相对复杂的项目，表格数量多到一定程度，在可视化管理工具中查阅浏览不太方便，这时，根据业务或功能对表格进行分类，加前缀也就有必要了。个人感觉是50张表内的数据库，加前缀意义不大，超过100张，则很有必要加前缀。而且我们要求，为了不给后期代码生成造成非必要麻烦，如果要给表加前缀，则所有表均要有前缀，不要出现有些表有、有些没有的情况。</p><p>表前缀主要是为了区分不同功能的表，而非解释表的功能，表的功能由表名来解释。前面要求表名的长度要控制在30个字符以内，在此前提下，为了尽可能不影响表的命名，表前缀应该越短越好。我们建议表前缀控制在两个以内。具体表前缀添加规则建议如下，括号内的单个大写字母表示要添加的前缀。这里以Oracle数据库为例，具体表名、前缀的大小写根据实际数据库参照“命名规范”——“名大小写”章节的说明：</p><p>a． 系统表（S_）：System，系统配置相关的基本信息表。系统用户表（S_USER）、系统角色表（S_ROLE）、系统菜单（S_LINK_MENU）、操作日志（S_OPERATION_LOG）、登录日志（S_LOGIN_LOG）、系统字典（S_DICTIONARY）、系统字典类型（S_DICTIONARY_TYPE）等。</p><p>b． 字典表（D_）：Dictionary，非系统字典外的字典表。在“设计规范”——“相关注释”——“字典字段”中提到过字典表的定义，除了数据库中的通用字典表，还有一些常见表，比如地区表（D_REGION）、ICD编码（D_ICD）等，也是一种字典表，这里的D_前缀即加在这类字典表名前面。</p><p>c． 中间表（R_）：Relationship，多对多关系中间表。具体命名方式建议为：R_主表名_从表名，在多对多关系中其实不分主从表，这里我们规定核心表为主表，另外一个为从表。比如用户角色关系中，用户表（S_USER）为主、角色（S_ROLE）表为从，那中间表就命名为R_USER_ROLE。当中间表名超长时，则根据实际情况缩写主从表名，建议优先缩写从表表名。</p><p>d． 业务表（B_）：Business，核心业务涉及的基本信息表。这里的业务是非系统配置业务相关的，比如登录、注册、权限这些业务涉及的表都是和系统配置相关的，前缀应该是S_，而非B_。比如在线商城的项目中订单业务涉及的表即是核心业务表，会诊系统中会诊单业务涉及的表即是核心业务表，如果项目庞大，涉及业务较多，可以在B后面继续加单字母区分不同的业务，BA_、BB_、BC_……，没必要非得和某个英文对应，只是个代号，和项目组的人员说明即可。</p><p>表名前缀的说明如上，已经足够明确，除此外还应该避免无谓的表格后缀。比如存储客户信息的表直接命名为Guest而非GuestInfo，存储航班信息的表直接命名为Flight而非FlightList。还有命名表时，一律使用单数形式。例如，使用 Employee，而不是 Employees，总之，表的命名应该简单明了。</p><blockquote><p>D.关于表字段的命名</p></blockquote><p>a． 所有表中的主键统一命名为id，主键统一使用UUID，类型统一为char(32)。 不建议使用复合主键，即便是在多对多关系的中间表中，个人还是建议用单独的字段做主键，复合字段加惟一约束。</p><p>b． 所有的表字段中，除外键，其它字段名都无需刻意加前后缀，也不要在字段名前出现表名。这里的外键是广义上的外键，不仅包括从表引用主表主键的外键字段，还包括存放主表相应关键信息的扩展字段。</p><p>比如病人表（Patient），主键就是id而不是pateint_id，名称就是name而不是patient_name。但对于外键，比如其它表引用Patient表的主键那就是patient_id，对应Patient表的name字段那就是patient_name。如果一个表中有多个外键（字段）同时引用（对应）一张表的同一个字段，那再用其它标识，比如在“设计规范”——“基本原则”——“主键外键”中提到的会诊单申请表中会诊发起医院（sender_hopital_id）和会诊接收医院（receiver_hospital_id）。</p><p>在前面的“设计规范”——“基本原则”——“主键外键”和“设计规范”——“约束控制”中有提到主键字段和外键字段的命名 ，这里再次做以上说明。另，PD中在由CDM转换成PDM时，会自动根据引用关系在从表中添加外键字段，可以自定义外键名称的命名规则：</p><p><img src="https://pic1.zhimg.com/v2-5506f2fd741969bc5109166d53025a70_b.png" alt="image"></p><p>c． 在前面的“设计规范”——“基本原则”——“连接查询”和“设计规范”——“相关注释”——“字典字段”有关于字典字段的详细介绍，这里再次说明其命名方式：对于字典字段，编码字段后面跟Code后缀，文本字段跟Text后缀，比如gender_code、gender_text。</p><p>d． 本规范中要求所有表示日期时间的字段，都要有后缀，如果只精确到天则以Date为后缀，如果要精确到时分秒那就用Time作后缀。在“设计规范”——“字段设置”——“通用字段处理”中有关于日期时间类型设置的说明，要求日期时间类型的字段，尽可能精确到时分秒，即便是像生日（birth_date）这种字段，一般只存储到年月日，但在选择字段类型时建议还是为datetime而非date。所以这里的后缀并不是和具体字段类型对应，而是根据实际业务情况，这个字段存储的数据多是精确到年月日还是时分秒，则后缀相应的为Date或Time。</p><p>网上有建议说，日期时间不要用Time做后缀，因为Time还有一个很常用的意思，就是次数。比如登录日志表中有用户最后一次登录时间字段login_time，不去看表的内容，很容易将login_time理解成登录的次数。这里我们不予考虑，只要内部统一规范，这就不会是个问题。</p><p>e． 本规范中建议是否注销、是否成功等类似的布尔型字段，名称前统一加is前缀，比如是否成功（is_success）、是否注销（is_active）、是否显示（is_display）等。</p><p>f． 关于一些通用字段的命名方式建议如下，仅作参考：   </p><p><img src="https://pic1.zhimg.com/v2-ac7295f07397e0e523daa4afff848838_b.png" alt="image"></p><blockquote><p>E.关于约束控制命名</p></blockquote><p>在“设计规范”——“约束控制”中介绍过五种约束类型：唯一性和主键约束、外键约束、检查约束、空值约束、默认值约束， 本规范中仅对外键约束的命名做要求，因外键约束标明着表与表之间的关系。我们建议外键约束以fk做前缀，后跟从表名称和主表名称：fk_从表名<em>主表名。这种定义方式，约束名称很容易超长，比如在Oracle中，约束名称的长度限制和表名一样，不能超过30个字符。如果超长，我们建议从后向前自动截取多出部分。前面提到过，CDM转换成PDM时会自动根据引用关系在从表中添加外键字段，外键名称的命名规则可以自定义。外键约束名称没必要手动添加，在PD的PDM图中选择：Database——Edit current DBMS——General选项卡——右侧树形菜单 Script\Objects\Reference\ConstName ，在里面可以编辑ConstraintName的命名方式，交由PD自动统一处理，比如可设置为：FK</em>%.U30:CHILD%_%.U30:PARENT%。此设置在PD 15中起作用，16版本中的设置没找到。</p><p>其它四种约束的命名，本规范中不做要求，窃以为这些约束怎样命名也不太重要，如果需要统一命名规范， 有些也可借助PD工具进行统一设置。</p><blockquote><p>F.其它功能块的命名</p></blockquote><p>前面说过，因为自己所主张的开发模式，以往的项目中很少在数据库中建存储过程、触发器、函数、序列、事件甚至是视图等，这里只根据经验，给出少量建议。</p><p>视图的命名和表的命名有很多相似点，但认为视图的名称最好可直接反应出其查询的主表，或者可明确反应出视图功能。存储过程、触发器、函数、索引的名称则直接反应其功能为好，其命名方式类似于在编程语言中给某一方法命名。序列只在Oracle中有，一般用来填充主键和计数。在早期的数据库设计中，喜欢用自增主键，比如要让用户表（USER）的主键ID自增，则创建名为SQ_USER_ID的序列和名为TR_SET_USER_ID的触发器。序列名直接反应出自己要计数的表的列，触发器名直接反应出自己的功能，这种命名方式或可借鉴。</p><p>不过后期项目的数据库设计，自己不再用自增主键，原因在“设计原则”——“基本规范”——“主键外键”中有描述。如果项目庞大，数据库设计的模式有变动，要大量使用存储过程、触发器、函数、序列等，对于这些部分的命名还是有必要规范化的。</p><h2 id="梳理总结"><a href="#梳理总结" class="headerlink" title="梳理总结"></a><strong>梳理总结</strong></h2><p>“命名规范”牵涉的细节太多，在介绍过程中也一直妄求事无巨细，反而导致有些地方比较散乱，这里把关键部分梳理总结如下：</p><p>a． 建议在SQLServer中将排序规则设置为Chinese_PRC_CS_AS，在MySQL数据库中将Character Set设置为utf8、将Collation设置为utf8_bin，并在数据库配置文件中设置lower_case_table_names=1，</p><p>b． 数据库、表、字段等所有名称的可用字符范围为：A-Z，a-z， 0-9 和_下划线，长度要严格控制在30个字符以内。</p><p>c． 数据库、表、字段等所有名称均使用英文单词或英文短语或相应缩写，均使用单数名，禁止使用汉语拼音。</p><p>d． Oracle表、字段等名称的统一使用大写，单词间用<em>下划线分隔；SQLServer数据库、表等名称采用Pascal命名法，字段名称采用Camel命名法；MySQL数据库、表、字段等名称统一使用小写，单词间用</em>下划线分隔。</p><p>e． 表主键统一命名为id，主键统一使用UUID，类型统一为char(32)。</p><p>f． 表（广义）外键建议命名为：主表名_字段名，类型和主表中字段类型一样。如果一个表中有多个外键（字段）同时引用（对应）一张表的同一个字段，再根据实际情况加前后缀区分</p><p>g． 对于字典字段，编码字段后面跟Code后缀，文本字段跟Text后缀，</p><p>h． 表示日期时间的字段，都要有后缀，如果只精确到天则以Date为后缀，如果要精确到时分秒那就用Time作后缀。</p><p>i． 建议是否注销、是否成功等类似的布尔型字段，名称前统一加is前缀，比如是否成功（is_success）、是否注销（is_active）、是否显示（is_display）等。</p><p>j． 建议外键约束以fk做前缀，后跟从表名称和主表名称：fk_从表名_主表名。 </p><p>转自: <a href="https://www.zhihu.com/question/26026443" target="_blank" rel="noopener">https://www.zhihu.com/question/26026443</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;数据库设计过程中表、字段等的命名规范也算是设计规范的一部分，设计规范更多的是为了确保数据库设计的合理性、为了项目最终的协调稳定性，而命名规范则更多的是为了确保设计的正式和统一. 公正的讲，数据库中表字段等等以什么样的方式命名、取具体什么名字，并不会直接影响到项目的稳定性.&lt;
      
    
    </summary>
    
    
      <category term="数据库" scheme="https://bmwu.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Expect: 100-Continue</title>
    <link href="https://bmwu.github.io/2017/09/20/Expect-100-Continue/"/>
    <id>https://bmwu.github.io/2017/09/20/Expect-100-Continue/</id>
    <published>2017-09-20T11:26:53.000Z</published>
    <updated>2019-05-21T04:11:57.573Z</updated>
    
    <content type="html"><![CDATA[<p>昨天碰到个客户问题, 客户用HttpClient发送请求, 结果返回的<a href="http://maikoushuo.com/2017/09/19/HttpClient%E9%95%BF%E8%BF%9E%E6%8E%A5%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener">response出现NoHttpResponseException的异常</a>. 昨天自己写了个测试用例跑了下, 以为问题解决了. 结果今天客户报还是有问题.  一阵苦恼.</p><p>后来比较了我的测试用例和客户的代码发现有细微出入: isExpectContinueEnabled. 这个method到底是何方神圣呢, 首先贴修改后的代码, 只加了<code>requestBuilder = requestBuilder.setExpectContinueEnabled(true);</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> HttpClient <span class="title">getHttpClient</span><span class="params">(<span class="keyword">int</span> timeout)</span> </span>&#123;</span><br><span class="line">  RequestConfig.Builder requestBuilder = RequestConfig.custom();</span><br><span class="line">  requestBuilder = requestBuilder.setConnectTimeout(timeout);</span><br><span class="line">  requestBuilder = requestBuilder.setSocketTimeout(timeout);</span><br><span class="line">  requestBuilder = requestBuilder.setExpectContinueEnabled(<span class="keyword">true</span>);</span><br><span class="line">  requestBuilder = requestBuilder.setConnectionRequestTimeout(timeout);</span><br><span class="line"></span><br><span class="line">  HttpClientBuilder builder = HttpClientBuilder.create();</span><br><span class="line">  builder.setDefaultRequestConfig(requestBuilder.build());</span><br><span class="line">  <span class="keyword">return</span> builder.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着我们来细把一下, 正宗官方说明: <a href="https://hc.apache.org/httpcomponents-client-ga/httpclient/apidocs/org/apache/http/client/config/RequestConfig.html#isExpectContinueEnabled(" target="_blank" rel="noopener">isExpectContinueEnabled</a>)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public boolean isExpectContinueEnabled()</span><br><span class="line">Determines whether the &apos;Expect: 100-Continue&apos; handshake is enabled for entity enclosing methods. The purpose of the &apos;Expect: 100-Continue&apos; handshake is to allow a client that is sending a request message with a request body to determine if the origin server is willing to accept the request (based on the request headers) before the client sends the request body.</span><br><span class="line">The use of the &apos;Expect: 100-continue&apos; handshake can result in a noticeable performance improvement for entity enclosing requests (such as POST and PUT) that require the target server&apos;s authentication.</span><br><span class="line"></span><br><span class="line">&apos;Expect: 100-continue&apos; handshake should be used with caution, as it may cause problems with HTTP servers and proxies that do not support HTTP/1.1 protocol.</span><br><span class="line"></span><br><span class="line">Default: false</span><br></pre></td></tr></table></figure><p>估计大部分人看的云里雾里的, 那这篇文章<a href="https://support.urbanairship.com/hc/en-us/articles/213492003--Expect-100-Continue-Issues-and-Risks" target="_blank" rel="noopener">‘Expect: 100-Continue’ Issues and Risks</a>就道出了原因, </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">How the Expect: 100-Continue Header Works</span><br><span class="line"></span><br><span class="line">When Expect: 100-Continue is NOT present, HTTP follows approximately the following flow (from the client&apos;s point of view):</span><br><span class="line"></span><br><span class="line">The request initiates a TCP connection to the server.</span><br><span class="line">When the connection to the server is established, the full request--which includes both the request headers and the request body--is transmitted to the server.</span><br><span class="line">The client waits for a response from the server (comprised of response headers and a response body).</span><br><span class="line">If HTTP keep-alives are supported, the request is optionally repeated from step 2.</span><br><span class="line">When the client is using the Expect: 100-Continue feature, the following events occur:</span><br><span class="line"></span><br><span class="line">The request initiates a TCP connection to the server.</span><br><span class="line">When the connection to the server is established, the request--including the headers, the Expect: 100-Continue header, without the request body--is then transmitted to the server.</span><br><span class="line">The client then waits for a response from the server.</span><br><span class="line">If the status code is a final status code, using the prior steps above the client retries the request without Expect: 100-Continue header.</span><br><span class="line">If the status code is 100-Continue, the request body is sent to the server.</span><br><span class="line">The client will then wait for a response from the server (comprised of response headers and a response body).</span><br><span class="line">If HTTP keep-alives are supported, the request is optionally repeated from step 2</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;昨天碰到个客户问题, 客户用HttpClient发送请求, 结果返回的&lt;a href=&quot;http://maikoushuo.com/2017/09/19/HttpClient%E9%95%BF%E8%BF%9E%E6%8E%A5%E9%97%AE%E9%A2%98/&quot; ta
      
    
    </summary>
    
    
      <category term="Http" scheme="https://bmwu.github.io/tags/Http/"/>
    
  </entry>
  
  <entry>
    <title>Maven - No plugin found for prefix &#39;tomcat7&#39; in the current project and in the plugin groups</title>
    <link href="https://bmwu.github.io/2017/09/20/Maven-No-plugin-found-for-prefix-tomcat7-in-the-current-project-and-in-the-plugin-groups/"/>
    <id>https://bmwu.github.io/2017/09/20/Maven-No-plugin-found-for-prefix-tomcat7-in-the-current-project-and-in-the-plugin-groups/</id>
    <published>2017-09-20T07:04:32.000Z</published>
    <updated>2019-05-21T04:11:57.575Z</updated>
    
    <content type="html"><![CDATA[<h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p>直接正式进入主题: 当<code>mvn tomcat7:run</code>时, 抛出了”Maven - No plugin found for prefix ‘tomcat7’ in the current project and in the  plugin groups”. 该怎么解决?</p><p>Ans: You are probably executing this command NOT from <strong>your web project</strong>. </p><h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p>Maven如何使用<a href="https://tomcat.apache.org/maven-plugin-trunk/tomcat7-maven-plugin/plugin-info.html" target="_blank" rel="noopener">tomcat7插件</a>, tomcat7-maven-plugin <a href="http://tomcat.apache.org/maven-plugin.html" target="_blank" rel="noopener">插件官网</a></p><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><p><a href="https://tomcat.apache.org/maven-plugin-trunk/tomcat7-maven-plugin/run-mojo.html" target="_blank" rel="noopener">tomcat7:run</a><br>运行当前项目</p><p><a href="https://tomcat.apache.org/maven-plugin-trunk/tomcat7-maven-plugin/deploy-mojo.html" target="_blank" rel="noopener">tomcat7:deploy</a><br>部署当前项目</p><p><a href="https://tomcat.apache.org/maven-plugin-trunk/tomcat7-maven-plugin/deploy-mojo.html" target="_blank" rel="noopener">tomcat7:redeploy</a><br>重新部署项目</p><p><a href="https://tomcat.apache.org/maven-plugin-trunk/tomcat7-maven-plugin/exec-war-mojo.html" target="_blank" rel="noopener">tomcat7:exec-war</a><br>创建一个可执行的jar文件，允许使用java -jar mywebapp.jar 运行web项目</p><p><a href="https://tomcat.apache.org/maven-plugin-trunk/tomcat7-maven-plugin/undeploy-mojo.html" target="_blank" rel="noopener">tomcat7:undeploy</a><br>取消部署一个war</p><p><a href="https://tomcat.apache.org/maven-plugin-trunk/tomcat7-maven-plugin/help-mojo.html" target="_blank" rel="noopener">tomcat7:help</a><br>在tomcat7-maven-plugin显示帮助信息</p><h3 id="pom-xml文件配置"><a href="#pom-xml文件配置" class="headerlink" title="pom.xml文件配置"></a>pom.xml文件配置</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- tomcat7插件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat7-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;tomcat.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">port</span>&gt;</span>$&#123;webserver.port&#125;<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">path</span>&gt;</span>/$&#123;project.artifactId&#125;<span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">uriEncoding</span>&gt;</span>$&#123;project.build.sourceEncoding&#125;<span class="tag">&lt;/<span class="name">uriEncoding</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;主题&quot;&gt;&lt;a href=&quot;#主题&quot; class=&quot;headerlink&quot; title=&quot;主题&quot;&gt;&lt;/a&gt;主题&lt;/h2&gt;&lt;p&gt;直接正式进入主题: 当&lt;code&gt;mvn tomcat7:run&lt;/code&gt;时, 抛出了”Maven - No plugin found 
      
    
    </summary>
    
    
      <category term="Maven" scheme="https://bmwu.github.io/tags/Maven/"/>
    
  </entry>
  
  <entry>
    <title>Google jsapi</title>
    <link href="https://bmwu.github.io/2017/09/20/Google-jsapi/"/>
    <id>https://bmwu.github.io/2017/09/20/Google-jsapi/</id>
    <published>2017-09-20T05:55:27.000Z</published>
    <updated>2019-05-21T04:11:57.573Z</updated>
    
    <content type="html"><![CDATA[<p>第一次接触Google JSAPI是因为妹子说JSAPI被墙了, 哈哈哈, 借此机会记录下. </p><p>妹子问我: <code>&lt;https://www.google.com/jsapi&gt; 你有这个cdn接口么？</code> </p><p>我一脸懵逼的回到: <code>说实话 &lt;https://www.google.com/jsapi&gt; 你有这个cdn接口么？这句话什么意思</code></p><p>生活就是这样, 处处可以发现惊喜. </p><p><strong><a href="https://developers.google.com/loader/" target="_blank" rel="noopener">Google API loader</a></strong> allows you to easily import one or more APIs, and specify additional settings (such as language, location, API version, etc.) applicable to your needs.</p><p>In addition to the basic loader functionality, savvy developers can also use dynamic loading or auto-loading to enhance the performance of your application.</p><p><a href="https://stackoverflow.com/questions/547384/where-do-you-include-the-jquery-library-from-google-jsapi-cdn" target="_blank" rel="noopener">Where do you include the jQuery library from? Google JSAPI? CDN?</a></p><p>这篇文章, 甚至可以说是篇调查问卷, 讲述了我们到底会采用哪种方式来包含jQuery和jQuery UI. 里面也讲述了当jsapi被强了的一种解决方案(妹子试验了, 无用), 哈哈哈, 但这并不影响我理解这些概念.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;第一次接触Google JSAPI是因为妹子说JSAPI被墙了, 哈哈哈, 借此机会记录下. &lt;/p&gt;
&lt;p&gt;妹子问我: &lt;code&gt;&amp;lt;https://www.google.com/jsapi&amp;gt; 你有这个cdn接口么？&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;我一脸懵逼的
      
    
    </summary>
    
    
      <category term="jsapi" scheme="https://bmwu.github.io/tags/jsapi/"/>
    
  </entry>
  
  <entry>
    <title>HttpClient长连接问题</title>
    <link href="https://bmwu.github.io/2017/09/19/HttpClient%E9%95%BF%E8%BF%9E%E6%8E%A5%E9%97%AE%E9%A2%98/"/>
    <id>https://bmwu.github.io/2017/09/19/HttpClient长连接问题/</id>
    <published>2017-09-19T09:29:55.000Z</published>
    <updated>2019-05-21T04:11:57.574Z</updated>
    
    <content type="html"><![CDATA[<h2 id="httpclient-出现NoHttpResponseException的异常解决"><a href="#httpclient-出现NoHttpResponseException的异常解决" class="headerlink" title="httpclient 出现NoHttpResponseException的异常解决"></a>httpclient 出现NoHttpResponseException的异常解决</h2><p>用httpClient写了个简单的测试:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="comment">// 测试长连接问题</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">keepAlive</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  Map&lt;String, String&gt; params = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">  params.put(<span class="string">"id"</span>, <span class="string">"id"</span>);</span><br><span class="line">  HttpClient  httpClient = getHttpClient(<span class="number">30000</span>);</span><br><span class="line">  HttpClientPost(httpClient, <span class="string">"http://127.0.0.1:6500/test"</span>, <span class="string">"utf-8"</span>, params);</span><br><span class="line">  HttpClientPost(httpClient, <span class="string">"http://127.0.0.1:6500/test"</span>, <span class="string">"utf-8"</span>, params);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> HttpClient <span class="title">getHttpClient</span><span class="params">(<span class="keyword">int</span> timeout)</span> </span>&#123;</span><br><span class="line">  RequestConfig.Builder requestBuilder = RequestConfig.custom();</span><br><span class="line">  requestBuilder = requestBuilder.setConnectTimeout(timeout);</span><br><span class="line">  requestBuilder = requestBuilder.setSocketTimeout(timeout);</span><br><span class="line">  requestBuilder = requestBuilder.setConnectionRequestTimeout(timeout);</span><br><span class="line"></span><br><span class="line">  HttpClientBuilder builder = HttpClientBuilder.create();</span><br><span class="line">  builder.setDefaultRequestConfig(requestBuilder.build());</span><br><span class="line">  <span class="keyword">return</span> builder.build();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">HttpClientPost</span><span class="params">(HttpClient httpclient, String url , String charset , Map&lt;String, String&gt; map)</span> <span class="keyword">throws</span> Exception  </span>&#123;</span><br><span class="line">  HttpPost httpPost = <span class="keyword">new</span> HttpPost(url);</span><br><span class="line">  List&lt;NameValuePair&gt; nvps = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; obj : map.entrySet()) &#123;</span><br><span class="line">    nvps.add(<span class="keyword">new</span> BasicNameValuePair(obj.getKey() , obj.getValue()));</span><br><span class="line">  &#125;</span><br><span class="line">  httpPost.setEntity(<span class="keyword">new</span> UrlEncodedFormEntity(nvps));</span><br><span class="line">  HttpResponse response2 = httpclient.execute(httpPost);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    HttpEntity entity2 = response2.getEntity();</span><br><span class="line">    System.out.println(EntityUtils.toString(entity2));</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>maven<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.httpcomponents<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>httpclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>但在测试过程中发现，第一次没有问题, 接下来出现如下的异常</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">org.apache.http.NoHttpResponseException: 127.0.0.1:80 failed to respond</span><br><span class="line">at org.apache.http.impl.conn.DefaultHttpResponseParser.parseHead(DefaultHttpResponseParser.java:143)</span><br><span class="line">at org.apache.http.impl.conn.DefaultHttpResponseParser.parseHead(DefaultHttpResponseParser.java:57)</span><br></pre></td></tr></table></figure><p>网上查了相关的报错信息，找到官网上的描述</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.apache.commons.httpclient.NoHttpResponseException java.io.IOException +- org.apache.commons.httpclient.NoHttpResponseExceptionIn some circumstances, usually when under heavy load, the web server may be able to receive requests but unable to process them. A lack of sufficient resources like worker threads is a good example. This may cause the server to drop the connection to the client without giving any response. HttpClient throws NoHttpResponseException when it encounters such a condition. In most cases it is safe to retry a method that failed with NoHttpResponseException.</span><br></pre></td></tr></table></figure><p>根据描述主要就是因为服务端断开连接，但并没有通知客户端，导致下次请求该服务时httpclient继续使用该连接导致报错。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;httpclient-出现NoHttpResponseException的异常解决&quot;&gt;&lt;a href=&quot;#httpclient-出现NoHttpResponseException的异常解决&quot; class=&quot;headerlink&quot; title=&quot;httpclient
      
    
    </summary>
    
    
      <category term="Http" scheme="https://bmwu.github.io/tags/Http/"/>
    
  </entry>
  
  <entry>
    <title>IAAS, SAAS, PAAS</title>
    <link href="https://bmwu.github.io/2017/09/18/IAAS-SAAS-PAAS/"/>
    <id>https://bmwu.github.io/2017/09/18/IAAS-SAAS-PAAS/</id>
    <published>2017-09-18T02:37:37.000Z</published>
    <updated>2019-05-21T04:11:57.574Z</updated>
    
    <content type="html"><![CDATA[<p><strong>原文</strong>是<strong>Pizza‐as‐a‐Service: a detailed view</strong>，用来类比Cloud Service Models。出处来自于Data Sovereignty and the Cloud – A Board and Executive Officers Guide University of NSW Faculty of Law, July 2013。</p><p>来源地址：<a href="http://www.chinacloud.cn/show.aspx?id=19758&amp;cid=18" target="_blank" rel="noopener">如何理解云计算？很简单，就像吃货想吃披萨了…</a></p><p>云计算的三个分层，基础设施在最下端，平台在中间，软件在顶端，分别是分别是<strong>Infrastructure-as-a-Service(IaaS)</strong>，<strong>Platform-as-a-Service(PaaS)</strong>，<strong>Software-as-a-Service(SaaS)</strong>，别的一些“软”的层可以在这些层上面添加.<br>而你的公司什么都有，现在所处的状态叫本地部署<strong>(On-Premises)</strong>，就像在自己家做pizza一样。<br><img src="http://maikoushuo.oss-cn-beijing.aliyuncs.com/%E4%BA%91%E8%AE%A1%E7%AE%97.png" alt="image"></p><p>几年前如果你想在办公室或者公司的网站上运行一些企业应用，你需要去买服务器，或者别的高昂的硬件来控制本地应用，让你的业务运行起来，这就叫本地部署。<br>假如你家BOSS突然有一天想明白了，只是为了吃上pizza，为什么非要自己做呢?于是，准备考虑一家云服务供应商，这个云服务供应商能提供哪些服务呢?其所能提供的云服务也就是云计算的三个分层：IaaS、PaaS和SaaS，就像pizza店提供三种服务：买成品回家做、外卖和到披萨店吃。<br><img src="http://maikoushuo.oss-cn-beijing.aliyuncs.com/%E4%BA%91%E8%AE%A1%E7%AE%971.png" alt="image"></p><h2 id="现在我们来谈谈具体细节。"><a href="#现在我们来谈谈具体细节。" class="headerlink" title="现在我们来谈谈具体细节。"></a>现在我们来谈谈具体细节。</h2><h3 id="IaaS-Infrastructure-as-a-Service-基础设施即服务"><a href="#IaaS-Infrastructure-as-a-Service-基础设施即服务" class="headerlink" title="IaaS: Infrastructure-as-a-Service(基础设施即服务)"></a>IaaS: Infrastructure-as-a-Service(基础设施即服务)</h3><p>有了IaaS，你可以将硬件外包到别的地方去。IaaS公司会提供场外服务器，存储和网络硬件，你可以租用。节省了维护成本和办公场地，公司可以在任何时候利用这些硬件来运行其应用。一些大的IaaS公司包括Amazon, Microsoft, VMWare, Rackspace和Red Hat.不过这些公司又都有自己的专长，比如Amazon和微软给你提供的不只是IaaS，他们还会将其计算能力出租给你来host你的网站。</p><h3 id="PaaS-Platform-as-a-Service-平台即服务"><a href="#PaaS-Platform-as-a-Service-平台即服务" class="headerlink" title="PaaS: Platform-as-a-Service(平台即服务)"></a>PaaS: Platform-as-a-Service(平台即服务)</h3><p>第二层就是所谓的PaaS，某些时候也叫做中间件。你公司所有的开发都可以在这一层进行，节省了时间和资源。PaaS公司在网上提供各种开发和分发应用的解决方案，比如虚拟服务器和操作系统。这节省了你在硬件上的费用，也让分散的工作室之间的合作变得更加容易。网页应用管理，应用设计，应用虚拟主机，存储，安全以及应用开发协作工具等。一些大的PaaS提供者有Google App Engine,Microsoft Azure，Force.com,Heroku，Engine Yard。最近兴起的公司有AppFog,Mendix和Standing Cloud.</p><h3 id="SaaS-Software-as-a-Service-软件即服务"><a href="#SaaS-Software-as-a-Service-软件即服务" class="headerlink" title="SaaS: Software-as-a-Service(软件即服务)"></a>SaaS: Software-as-a-Service(软件即服务)</h3><p>第三层也就是所谓SaaS。这一层是和你的生活每天接触的一层，大多是通过网页浏览器来接入。任何一个远程服务器上的应用都可以通过网络来运行，就是SaaS了。你消费的服务完全是从网页如Netflix,MOG,Google Apps,Box.net,Dropbox或者苹果的iCloud那里进入这些分类。尽管这些网页服务是用作商务和娱乐或者两者都有，但这也算是云技术的一部分。一些用作商务的SaaS应用包括Citrix的Go To Meeting，Cisco的WebEx，Salesforce的CRM，ADP，Workday和SuccessFactors。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;原文&lt;/strong&gt;是&lt;strong&gt;Pizza‐as‐a‐Service: a detailed view&lt;/strong&gt;，用来类比Cloud Service Models。出处来自于Data Sovereignty and the Cloud – A
      
    
    </summary>
    
    
      <category term="云计算" scheme="https://bmwu.github.io/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>定时备份MySQL数据库并删除N天前的备份文件</title>
    <link href="https://bmwu.github.io/2017/09/14/%E5%AE%9A%E6%97%B6%E5%A4%87%E4%BB%BDMySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B9%B6%E5%88%A0%E9%99%A4N%E5%A4%A9%E5%89%8D%E7%9A%84%E5%A4%87%E4%BB%BD%E6%96%87%E4%BB%B6/"/>
    <id>https://bmwu.github.io/2017/09/14/定时备份MySQL数据库并删除N天前的备份文件/</id>
    <published>2017-09-14T09:30:04.000Z</published>
    <updated>2019-05-21T04:11:57.579Z</updated>
    
    <content type="html"><![CDATA[<p>目标: 定时备份MYSQL, 避免有所疏漏, 确保开发数据不被丢失. 利用crontab来定时执行备份文件，按日期对备份结果进行保存，达到备份的目的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">创建备份文件夹</span></span><br><span class="line">mkdir mysqldata</span><br><span class="line"><span class="meta">#</span><span class="bash">编写运行脚本</span></span><br><span class="line">vi bakmysql.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">为脚本添加执行权限</span></span><br><span class="line">chmod +x /usr/sbin/bakmysql.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">修改/etc/crontab</span></span><br><span class="line">sodu vi /etc/crontab </span><br><span class="line"><span class="meta">#</span><span class="bash">在最后一行中加入： </span></span><br><span class="line">00 3 * * * root /usr/sbin/bakmysql.sh</span><br><span class="line">表示每天3点00分执行备份</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">重启crontab</span></span><br><span class="line">sudo /usr/sbin/crond restart</span><br><span class="line"><span class="meta">#</span><span class="bash">重启不成功处理</span></span><br><span class="line">ps aux | grep $(cat /var/run/crond.pid)</span><br><span class="line">sudo rm -f /var/run/crond.pid</span><br><span class="line"><span class="meta">#</span><span class="bash">恢复数据备份文件：</span></span><br><span class="line">gunzip maikou2017010101.sql.gz</span><br><span class="line">mysql -u&#123;user&#125; -p&#123;password&#125; &#123;dataname&#125; &lt; maikou2017010101.sql</span><br></pre></td></tr></table></figure><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Name:bakmysql.sh</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> This is a ShellScript For Auto DB Backup and Delete old Backup</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line">backupdir=/home/deployer/bak/mysqldata</span><br><span class="line">time=` date +%Y%m%d%H `</span><br><span class="line">/usr/bin/mysqldump -u&#123;user&#125; -p&#123;password&#125; &#123;databse&#125; | gzip &gt; $backupdir/&#123;name&#125;$time.sql.gz</span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line">find $backupdir -name "&#123;name&#125;_*.sql.gz" -type f -mtime +5 -exec rm &#123;&#125; \; &gt; /dev/null 2&gt;&amp;1</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;目标: 定时备份MYSQL, 避免有所疏漏, 确保开发数据不被丢失. 利用crontab来定时执行备份文件，按日期对备份结果进行保存，达到备份的目的。&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gut
      
    
    </summary>
    
    
      <category term="MySQL" scheme="https://bmwu.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot日志配置</title>
    <link href="https://bmwu.github.io/2017/09/14/Spring-Boot-%E6%97%A5%E5%BF%97%E9%85%8D%E7%BD%AE/"/>
    <id>https://bmwu.github.io/2017/09/14/Spring-Boot-日志配置/</id>
    <published>2017-09-14T05:42:48.000Z</published>
    <updated>2019-05-21T06:52:45.745Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring-Boot-日志配置"><a href="#Spring-Boot-日志配置" class="headerlink" title="Spring Boot 日志配置"></a>Spring Boot 日志配置</h1><p>Spring Boot 采用 <code>Commons Logging</code> 作为内部的日志框架。对于日志的具体实现，则没有限制。默认的提供了对<code>Java Util Logging</code>，<code>Log4J2</code> 和 <code>Logback</code> 的支持。每种方式下，<code>Console</code>的日志输出，作为默认的日志输出。<br>在默认情况下，采用<code>Starters</code> 来启动Spring Boot 项目，<code>Logback</code> 是默认的日志实现方案。当然，Logback 路由能够保证依赖的包使用的其他日志也可以很好的工作。</p><p>maven依赖中添加了spring-boot-starter-logging：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="默认日志Logback"><a href="#默认日志Logback" class="headerlink" title="默认日志Logback"></a>默认日志Logback</h2><p><a href="http://www.slf4j.org/" target="_blank" rel="noopener">SLF4J</a>——Simple Logging Facade For <a href="http://lib.csdn.net/base/javase" target="_blank" rel="noopener">Java</a>，它是一个针对于各类Java日志框架的统一<a href="https://en.wikipedia.org/wiki/Facade_pattern" target="_blank" rel="noopener">Facade</a>抽象。Java日志框架众多——常用的有<code>java.util.logging</code>, <code>log4j</code>, <code>logback</code>，<code>commons-logging</code>, Spring框架使用的是Jakarta Commons Logging API (JCL)。而SLF4J定义了统一的日志抽象接口，而真正的日志实现则是在运行时决定的——它提供了各类日志框架的binding。</p><p><a href="http://logback.qos.ch/" target="_blank" rel="noopener">Logback</a>是log4j框架的作者开发的新一代日志框架，它效率更高、能够适应诸多的运行环境，同时天然支持SLF4J。</p><p>默认情况下，Spring Boot会用Logback来记录日志，并用INFO级别输出到控制台。在运行应用程序和其他例子时，你应该已经看到很多INFO级别的日志了。</p><p><img src="http://maikoushuo.oss-cn-beijing.aliyuncs.com/SpringBoot.png" alt="image"></p><p>从上图可以看到，日志输出内容元素具体如下：</p><ul><li>时间日期：精确到毫秒</li><li>日志级别：ERROR, WARN, INFO, DEBUG or TRACE</li><li>进程ID: 79996</li><li>分隔符：<code>---</code> 标识实际日志的开始</li><li>线程名：方括号括起来（可能会截断控制台输出）</li><li>Logger名：通常使用源代码的类名</li><li>日志内容</li></ul><p>那么，我们的Spring Boot应用将自动使用logback作为应用日志框架，Spring Boot启动的时候，由org.springframework.boot.logging.Logging-Application-Listener根据情况初始化并使用。</p><h3 id="日志输出文件"><a href="#日志输出文件" class="headerlink" title="日志输出文件"></a>日志输出文件</h3><p>默认情况下，Spring Boot将日志输出到控制台，不会写到日志文件。如果要编写除控制台输出之外的日志文件，则需在application.properties中设置logging.file或logging.path属性。</p><ul><li>logging.file，设置文件，可以是绝对路径，也可以是相对路径。如：<code>logging.file=my.log</code></li><li>logging.path，设置目录，会在该目录下创建spring.log文件，并写入日志内容，如：<code>logging.path=/var/log</code></li></ul><p>如果只配置 logging.file，会在项目的当前路径下生成一个 xxx.log 日志文件。<br>如果只配置 logging.path，在 /var/log文件夹生成一个日志文件为 spring.log</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#日志输出</span><br><span class="line">logging.file=logs/log.log</span><br><span class="line">logging.level.root=INFO</span><br><span class="line">logging.level.org.springframework.web=INFO</span><br><span class="line">logging.level.org.hibernate=ERROR</span><br></pre></td></tr></table></figure><blockquote><p>注：二者不能同时使用，如若同时使用，则只有logging.file生效</p></blockquote><p><strong>默认情况下，日志文件的大小达到10MB时会切分一次，产生新的日志文件，默认级别为：ERROR、WARN、INFO</strong></p><h3 id="自定义日志配置"><a href="#自定义日志配置" class="headerlink" title="自定义日志配置"></a>自定义日志配置</h3><p>由于日志服务一般都在ApplicationContext创建前就初始化了，它并不是必须通过Spring的配置文件控制。因此通过系统属性和传统的Spring Boot外部配置文件依然可以很好的支持日志控制和管理。</p><p>根据不同的日志系统，你可以按如下规则组织配置文件名，就能被正确加载：</p><ul><li>Logback：<code>logback-spring.xml</code>, <code>logback-spring.groovy</code>, <code>logback.xml</code>, <code>logback.groovy</code></li><li>Log4j：<code>log4j-spring.properties</code>, <code>log4j-spring.xml</code>, <code>log4j.properties</code>, <code>log4j.xml</code></li><li>Log4j2：<code>log4j2-spring.xml</code>, <code>log4j2.xml</code></li><li>JDK (Java Util Logging)：<code>logging.properties</code></li></ul><p><strong>Spring Boot官方推荐优先使用带有-spring的文件名作为你的日志配置（如使用logback-spring.xml，而不是logback.xml），命名为logback-spring.xml的日志配置文件，spring boot可以为它添加一些spring boot特有的配置项（下面会提到）。</strong></p><p>上面是默认的命名规则，并且放在<code>src/main/resources</code>下面即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Spring-Boot-日志配置&quot;&gt;&lt;a href=&quot;#Spring-Boot-日志配置&quot; class=&quot;headerlink&quot; title=&quot;Spring Boot 日志配置&quot;&gt;&lt;/a&gt;Spring Boot 日志配置&lt;/h1&gt;&lt;p&gt;Spring Boot 采用
      
    
    </summary>
    
    
      <category term="Spring Boot" scheme="https://bmwu.github.io/tags/Spring-Boot/"/>
    
  </entry>
  
</feed>
